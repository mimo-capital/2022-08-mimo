{
  "language": "Solidity",
  "sources": {
    "contracts/actions/automated/interfaces/IMIMOAutoAction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../../../core/interfaces/IAddressProvider.sol\";\nimport \"../../../proxy/interfaces/IMIMOProxyFactory.sol\";\n\ninterface IMIMOAutoAction {\n  struct AutomatedVault {\n    bool isAutomated;\n    address toCollateral;\n    uint256 allowedVariation;\n    uint256 targetRatio;\n    uint256 triggerRatio;\n    uint256 mcrBuffer;\n    uint256 fixedFee;\n    uint256 varFee;\n  }\n\n  struct VaultState {\n    address collateralType;\n    uint256 collateralValue;\n    uint256 vaultDebt;\n  }\n\n  event AutomationSet(uint256 indexed vaultId, AutomatedVault autoVault);\n\n  function setAutomation(uint256 vaultId, AutomatedVault calldata autoParams) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function proxyFactory() external view returns (IMIMOProxyFactory);\n\n  function getAutomatedVault(uint256 vaultId) external view returns (AutomatedVault memory);\n\n  function getOperationTracker(uint256 vaultId) external view returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"./IAccessController.sol\";\nimport \"./IConfigProvider.sol\";\nimport \"./ISTABLEX.sol\";\nimport \"./IPriceFeed.sol\";\nimport \"./IRatesManager.sol\";\nimport \"./ILiquidationManager.sol\";\nimport \"./IVaultsCore.sol\";\nimport \"./IVaultsDataProvider.sol\";\nimport \"./IFeeDistributor.sol\";\n\ninterface IAddressProvider {\n  function setAccessController(IAccessController _controller) external;\n\n  function setConfigProvider(IConfigProvider _config) external;\n\n  function setVaultsCore(IVaultsCore _core) external;\n\n  function setStableX(ISTABLEX _stablex) external;\n\n  function setRatesManager(IRatesManager _ratesManager) external;\n\n  function setPriceFeed(IPriceFeed _priceFeed) external;\n\n  function setLiquidationManager(ILiquidationManager _liquidationManager) external;\n\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;\n\n  function setFeeDistributor(IFeeDistributor _feeDistributor) external;\n\n  function controller() external view returns (IAccessController);\n\n  function config() external view returns (IConfigProvider);\n\n  function core() external view returns (IVaultsCore);\n\n  function stablex() external view returns (ISTABLEX);\n\n  function ratesManager() external view returns (IRatesManager);\n\n  function priceFeed() external view returns (IPriceFeed);\n\n  function liquidationManager() external view returns (ILiquidationManager);\n\n  function vaultsData() external view returns (IVaultsDataProvider);\n\n  function feeDistributor() external view returns (IFeeDistributor);\n}\n"
    },
    "contracts/proxy/interfaces/IMIMOProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\nimport \"./IMIMOProxy.sol\";\nimport \"./IMIMOProxyGuard.sol\";\n\n/// @title IMIMOProxyFactory\n/// @notice Deploys new proxies with CREATE2.\ninterface IMIMOProxyFactory {\n  struct ProxyState {\n    address owner;\n    IMIMOProxyGuard proxyGuard;\n    uint256 minGas;\n  }\n\n  event ProxyDeployed(address indexed owner, address indexed proxy, ProxyState proxyState);\n\n  event PermissionsCleared(address indexed proxy, address newProxyGuard);\n\n  event OwnershipTransferred(address indexed proxy, address indexed previousOwner, address indexed newOwner);\n\n  event OwnershipClaimed(address indexed proxy, address indexed newOwner);\n\n  event MinGasSet(address indexed proxy, uint256 minGas);\n\n  function deploy() external;\n\n  function transferOwnership(address proxy, address newOwner) external;\n\n  function claimOwnership(address proxy, bool clear) external;\n\n  function clearPermissions(address proxy) external;\n\n  function setMinGas(address proxy, uint256 minGas) external;\n\n  function mimoProxyGuardBase() external returns (address);\n\n  function isProxy(address proxy) external returns (bool result);\n\n  function VERSION() external view returns (uint256);\n\n  function getProxyState(address proxy) external view returns (ProxyState memory proxyState);\n\n  function getCurrentProxy(address owner) external view returns (IMIMOProxy proxy);\n\n  function getPendingOwner(address proxy) external view returns (address pendingOwner);\n}\n"
    },
    "contracts/core/interfaces/IAccessController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IAccessController {\n  event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n  event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n  event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n  function grantRole(bytes32 role, address account) external;\n\n  function revokeRole(bytes32 role, address account) external;\n\n  function renounceRole(bytes32 role, address account) external;\n\n  function MANAGER_ROLE() external view returns (bytes32);\n\n  function MINTER_ROLE() external view returns (bytes32);\n\n  function hasRole(bytes32 role, address account) external view returns (bool);\n\n  function getRoleMemberCount(bytes32 role) external view returns (uint256);\n\n  function getRoleMember(bytes32 role, uint256 index) external view returns (address);\n\n  function getRoleAdmin(bytes32 role) external view returns (bytes32);\n}\n"
    },
    "contracts/core/interfaces/IConfigProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IAddressProvider.sol\";\n\ninterface IConfigProvider {\n  struct CollateralConfig {\n    address collateralType;\n    uint256 debtLimit;\n    uint256 liquidationRatio;\n    uint256 minCollateralRatio;\n    uint256 borrowRate;\n    uint256 originationFee;\n    uint256 liquidationBonus;\n    uint256 liquidationFee;\n  }\n\n  event CollateralUpdated(\n    address indexed collateralType,\n    uint256 debtLimit,\n    uint256 liquidationRatio,\n    uint256 minCollateralRatio,\n    uint256 borrowRate,\n    uint256 originationFee,\n    uint256 liquidationBonus,\n    uint256 liquidationFee\n  );\n  event CollateralRemoved(address indexed collateralType);\n\n  function setCollateralConfig(\n    address _collateralType,\n    uint256 _debtLimit,\n    uint256 _liquidationRatio,\n    uint256 _minCollateralRatio,\n    uint256 _borrowRate,\n    uint256 _originationFee,\n    uint256 _liquidationBonus,\n    uint256 _liquidationFee\n  ) external;\n\n  function removeCollateral(address _collateralType) external;\n\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;\n\n  function setCollateralLiquidationRatio(address _collateralType, uint256 _liquidationRatio) external;\n\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;\n\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;\n\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;\n\n  function setCollateralLiquidationBonus(address _collateralType, uint256 _liquidationBonus) external;\n\n  function setCollateralLiquidationFee(address _collateralType, uint256 _liquidationFee) external;\n\n  function setMinVotingPeriod(uint256 _minVotingPeriod) external;\n\n  function setMaxVotingPeriod(uint256 _maxVotingPeriod) external;\n\n  function setVotingQuorum(uint256 _votingQuorum) external;\n\n  function setProposalThreshold(uint256 _proposalThreshold) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);\n\n  function collateralIds(address _collateralType) external view returns (uint256);\n\n  function numCollateralConfigs() external view returns (uint256);\n\n  function minVotingPeriod() external view returns (uint256);\n\n  function maxVotingPeriod() external view returns (uint256);\n\n  function votingQuorum() external view returns (uint256);\n\n  function proposalThreshold() external view returns (uint256);\n\n  function collateralDebtLimit(address _collateralType) external view returns (uint256);\n\n  function collateralLiquidationRatio(address _collateralType) external view returns (uint256);\n\n  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);\n\n  function collateralBorrowRate(address _collateralType) external view returns (uint256);\n\n  function collateralOriginationFee(address _collateralType) external view returns (uint256);\n\n  function collateralLiquidationBonus(address _collateralType) external view returns (uint256);\n\n  function collateralLiquidationFee(address _collateralType) external view returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/ISTABLEX.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\n\ninterface ISTABLEX is IERC20 {\n    function mint(address account, uint256 amount) external;\n\n    function burn(address account, uint256 amount) external;\n\n    function a() external view returns (IAddressProvider);\n}\n"
    },
    "contracts/core/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../chainlink/AggregatorV3Interface.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\n\ninterface IPriceFeed {\n  event OracleUpdated(address indexed asset, address oracle, address sender);\n  event EurOracleUpdated(address oracle, address sender);\n\n  function setAssetOracle(address _asset, address _oracle) external;\n\n  function setEurOracle(address _oracle) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function assetOracles(address _asset) external view returns (AggregatorV3Interface);\n\n  function eurOracle() external view returns (AggregatorV3Interface);\n\n  function getAssetPrice(address _asset) external view returns (uint256);\n\n  function convertFrom(address _asset, uint256 _amount) external view returns (uint256);\n\n  function convertTo(address _asset, uint256 _amount) external view returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IRatesManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IAddressProvider.sol\";\n\ninterface IRatesManager {\n  function a() external view returns (IAddressProvider);\n\n  //current annualized borrow rate\n  function annualizedBorrowRate(uint256 _currentBorrowRate) external pure returns (uint256);\n\n  //uses current cumulative rate to calculate totalDebt based on baseDebt at time T0\n  function calculateDebt(uint256 _baseDebt, uint256 _cumulativeRate) external pure returns (uint256);\n\n  //uses current cumulative rate to calculate baseDebt at time T0\n  function calculateBaseDebt(uint256 _debt, uint256 _cumulativeRate) external pure returns (uint256);\n\n  //calculate a new cumulative rate\n  function calculateCumulativeRate(\n    uint256 _borrowRate,\n    uint256 _cumulativeRate,\n    uint256 _timeElapsed\n  ) external view returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/ILiquidationManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IAddressProvider.sol\";\n\ninterface ILiquidationManager {\n  function a() external view returns (IAddressProvider);\n\n  function calculateHealthFactor(\n    uint256 _collateralValue,\n    uint256 _vaultDebt,\n    uint256 _minRatio\n  ) external view returns (uint256 healthFactor);\n\n  function liquidationBonus(address _collateralType, uint256 _amount) external view returns (uint256 bonus);\n\n  function applyLiquidationDiscount(address _collateralType, uint256 _amount)\n    external\n    view\n    returns (uint256 discountedAmount);\n\n  function isHealthy(\n    uint256 _collateralValue,\n    uint256 _vaultDebt,\n    uint256 _minRatio\n  ) external view returns (bool);\n}\n"
    },
    "contracts/core/interfaces/IVaultsCore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IVaultsCoreState.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../liquidityMining/interfaces/IDebtNotifier.sol\";\n\ninterface IVaultsCore {\n  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);\n  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Liquidated(\n    uint256 indexed vaultId,\n    uint256 debtRepaid,\n    uint256 collateralLiquidated,\n    address indexed owner,\n    address indexed sender\n  );\n\n  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);\n\n  function deposit(address _collateralType, uint256 _amount) external;\n\n  function depositETH() external payable;\n\n  function depositByVaultId(uint256 _vaultId, uint256 _amount) external;\n\n  function depositETHByVaultId(uint256 _vaultId) external payable;\n\n  function depositAndBorrow(\n    address _collateralType,\n    uint256 _depositAmount,\n    uint256 _borrowAmount\n  ) external;\n\n  function depositETHAndBorrow(uint256 _borrowAmount) external payable;\n\n  function withdraw(uint256 _vaultId, uint256 _amount) external;\n\n  function withdrawETH(uint256 _vaultId, uint256 _amount) external;\n\n  function borrow(uint256 _vaultId, uint256 _amount) external;\n\n  function repayAll(uint256 _vaultId) external;\n\n  function repay(uint256 _vaultId, uint256 _amount) external;\n\n  function liquidate(uint256 _vaultId) external;\n\n  function liquidatePartial(uint256 _vaultId, uint256 _amount) external;\n\n  function upgrade(address payable _newVaultsCore) external;\n\n  function acceptUpgrade(address payable _oldVaultsCore) external;\n\n  function setDebtNotifier(IDebtNotifier _debtNotifier) external;\n\n  //Read only\n  function a() external view returns (IAddressProvider);\n\n  function WETH() external view returns (IWETH);\n\n  function debtNotifier() external view returns (IDebtNotifier);\n\n  function state() external view returns (IVaultsCoreState);\n\n  function cumulativeRates(address _collateralType) external view returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IVaultsDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\nimport \"../interfaces/IAddressProvider.sol\";\n\ninterface IVaultsDataProvider {\n  struct Vault {\n    // borrowedType support USDX / PAR\n    address collateralType;\n    address owner;\n    uint256 collateralBalance;\n    uint256 baseDebt;\n    uint256 createdAt;\n  }\n\n  //Write\n  function createVault(address _collateralType, address _owner) external returns (uint256);\n\n  function setCollateralBalance(uint256 _id, uint256 _balance) external;\n\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;\n\n  // Read\n  function a() external view returns (IAddressProvider);\n\n  function baseDebt(address _collateralType) external view returns (uint256);\n\n  function vaultCount() external view returns (uint256);\n\n  function vaults(uint256 _id) external view returns (Vault memory);\n\n  function vaultOwner(uint256 _id) external view returns (address);\n\n  function vaultCollateralType(uint256 _id) external view returns (address);\n\n  function vaultCollateralBalance(uint256 _id) external view returns (uint256);\n\n  function vaultBaseDebt(uint256 _id) external view returns (uint256);\n\n  function vaultId(address _collateralType, address _owner) external view returns (uint256);\n\n  function vaultExists(uint256 _id) external view returns (bool);\n\n  function vaultDebt(uint256 _vaultId) external view returns (uint256);\n\n  function debt() external view returns (uint256);\n\n  function collateralDebt(address _collateralType) external view returns (uint256);\n}\n"
    },
    "contracts/core/interfaces/IFeeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IAddressProvider.sol\";\n\ninterface IFeeDistributor {\n  event PayeeAdded(address indexed account, uint256 shares);\n  event FeeReleased(uint256 income, uint256 releasedAt);\n\n  function release() external;\n\n  function changePayees(address[] memory _payees, uint256[] memory _shares) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function lastReleasedAt() external view returns (uint256);\n\n  function getPayees() external view returns (address[] memory);\n\n  function totalShares() external view returns (uint256);\n\n  function shares(address payee) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/core/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/core/interfaces/IVaultsCoreState.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\nimport \"./IAddressProvider.sol\";\nimport \"../v1/interfaces/IVaultsCoreV1.sol\";\n\ninterface IVaultsCoreState {\n  event CumulativeRateUpdated(address indexed collateralType, uint256 elapsedTime, uint256 newCumulativeRate); //cumulative interest rate from deployment time T0\n\n  function initializeRates(address _collateralType) external;\n\n  function refresh() external;\n\n  function refreshCollateral(address collateralType) external;\n\n  function syncState(IVaultsCoreState _stateAddress) external;\n\n  function syncStateFromV1(IVaultsCoreV1 _core) external;\n\n  //Read only\n  function a() external view returns (IAddressProvider);\n\n  function availableIncome() external view returns (uint256);\n\n  function cumulativeRates(address _collateralType) external view returns (uint256);\n\n  function lastRefresh(address _collateralType) external view returns (uint256);\n\n  function synced() external view returns (bool);\n}\n"
    },
    "contracts/core/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWETH is IERC20 {\n  function deposit() external payable;\n\n  function transfer(address to, uint256 value) external returns (bool);\n\n  function withdraw(uint256 wad) external;\n\n  function approve(address guy, uint256 wad) external returns (bool);\n}\n"
    },
    "contracts/core/liquidityMining/interfaces/IDebtNotifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"../../governance/interfaces/IGovernanceAddressProvider.sol\";\nimport \"./ISupplyMiner.sol\";\n\ninterface IDebtNotifier {\n    function debtChanged(uint256 _vaultId) external;\n\n    function setCollateralSupplyMiner(\n        address collateral,\n        ISupplyMiner supplyMiner\n    ) external;\n\n    function a() external view returns (IGovernanceAddressProvider);\n\n    function collateralSupplyMinerMapping(address collateral)\n        external\n        view\n        returns (ISupplyMiner);\n}\n"
    },
    "contracts/core/v1/interfaces/IVaultsCoreV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\nimport \"./IAddressProviderV1.sol\";\n\ninterface IVaultsCoreV1 {\n  event Opened(uint256 indexed vaultId, address indexed collateralType, address indexed owner);\n  event Deposited(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Withdrawn(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Borrowed(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Repaid(uint256 indexed vaultId, uint256 amount, address indexed sender);\n  event Liquidated(\n    uint256 indexed vaultId,\n    uint256 debtRepaid,\n    uint256 collateralLiquidated,\n    address indexed owner,\n    address indexed sender\n  );\n\n  event CumulativeRateUpdated(address indexed collateralType, uint256 elapsedTime, uint256 newCumulativeRate); //cumulative interest rate from deployment time T0\n\n  event InsurancePaid(uint256 indexed vaultId, uint256 insuranceAmount, address indexed sender);\n\n  function deposit(address _collateralType, uint256 _amount) external;\n\n  function withdraw(uint256 _vaultId, uint256 _amount) external;\n\n  function withdrawAll(uint256 _vaultId) external;\n\n  function borrow(uint256 _vaultId, uint256 _amount) external;\n\n  function repayAll(uint256 _vaultId) external;\n\n  function repay(uint256 _vaultId, uint256 _amount) external;\n\n  function liquidate(uint256 _vaultId) external;\n\n  //Refresh\n  function initializeRates(address _collateralType) external;\n\n  function refresh() external;\n\n  function refreshCollateral(address collateralType) external;\n\n  //upgrade\n  function upgrade(address _newVaultsCore) external;\n\n  //Read only\n\n  function a() external view returns (IAddressProviderV1);\n\n  function availableIncome() external view returns (uint256);\n\n  function cumulativeRates(address _collateralType) external view returns (uint256);\n\n  function lastRefresh(address _collateralType) external view returns (uint256);\n}\n"
    },
    "contracts/core/v1/interfaces/IAddressProviderV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"./IConfigProviderV1.sol\";\nimport \"./ILiquidationManagerV1.sol\";\nimport \"./IVaultsCoreV1.sol\";\nimport \"../../interfaces/IVaultsCore.sol\";\nimport \"../../interfaces/IAccessController.sol\";\nimport \"../../interfaces/ISTABLEX.sol\";\nimport \"../../interfaces/IPriceFeed.sol\";\nimport \"../../interfaces/IRatesManager.sol\";\nimport \"../../interfaces/IVaultsDataProvider.sol\";\nimport \"../../interfaces/IFeeDistributor.sol\";\n\ninterface IAddressProviderV1 {\n  function setAccessController(IAccessController _controller) external;\n\n  function setConfigProvider(IConfigProviderV1 _config) external;\n\n  function setVaultsCore(IVaultsCoreV1 _core) external;\n\n  function setStableX(ISTABLEX _stablex) external;\n\n  function setRatesManager(IRatesManager _ratesManager) external;\n\n  function setPriceFeed(IPriceFeed _priceFeed) external;\n\n  function setLiquidationManager(ILiquidationManagerV1 _liquidationManager) external;\n\n  function setVaultsDataProvider(IVaultsDataProvider _vaultsData) external;\n\n  function setFeeDistributor(IFeeDistributor _feeDistributor) external;\n\n  function controller() external view returns (IAccessController);\n\n  function config() external view returns (IConfigProviderV1);\n\n  function core() external view returns (IVaultsCoreV1);\n\n  function stablex() external view returns (ISTABLEX);\n\n  function ratesManager() external view returns (IRatesManager);\n\n  function priceFeed() external view returns (IPriceFeed);\n\n  function liquidationManager() external view returns (ILiquidationManagerV1);\n\n  function vaultsData() external view returns (IVaultsDataProvider);\n\n  function feeDistributor() external view returns (IFeeDistributor);\n}\n"
    },
    "contracts/core/v1/interfaces/IConfigProviderV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"./IAddressProviderV1.sol\";\n\ninterface IConfigProviderV1 {\n  struct CollateralConfig {\n    address collateralType;\n    uint256 debtLimit;\n    uint256 minCollateralRatio;\n    uint256 borrowRate;\n    uint256 originationFee;\n  }\n\n  event CollateralUpdated(\n    address indexed collateralType,\n    uint256 debtLimit,\n    uint256 minCollateralRatio,\n    uint256 borrowRate,\n    uint256 originationFee\n  );\n  event CollateralRemoved(address indexed collateralType);\n\n  function setCollateralConfig(\n    address _collateralType,\n    uint256 _debtLimit,\n    uint256 _minCollateralRatio,\n    uint256 _borrowRate,\n    uint256 _originationFee\n  ) external;\n\n  function removeCollateral(address _collateralType) external;\n\n  function setCollateralDebtLimit(address _collateralType, uint256 _debtLimit) external;\n\n  function setCollateralMinCollateralRatio(address _collateralType, uint256 _minCollateralRatio) external;\n\n  function setCollateralBorrowRate(address _collateralType, uint256 _borrowRate) external;\n\n  function setCollateralOriginationFee(address _collateralType, uint256 _originationFee) external;\n\n  function setLiquidationBonus(uint256 _bonus) external;\n\n  function a() external view returns (IAddressProviderV1);\n\n  function collateralConfigs(uint256 _id) external view returns (CollateralConfig memory);\n\n  function collateralIds(address _collateralType) external view returns (uint256);\n\n  function numCollateralConfigs() external view returns (uint256);\n\n  function liquidationBonus() external view returns (uint256);\n\n  function collateralDebtLimit(address _collateralType) external view returns (uint256);\n\n  function collateralMinCollateralRatio(address _collateralType) external view returns (uint256);\n\n  function collateralBorrowRate(address _collateralType) external view returns (uint256);\n\n  function collateralOriginationFee(address _collateralType) external view returns (uint256);\n}\n"
    },
    "contracts/core/v1/interfaces/ILiquidationManagerV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"./IAddressProviderV1.sol\";\n\ninterface ILiquidationManagerV1 {\n  function a() external view returns (IAddressProviderV1);\n\n  function calculateHealthFactor(\n    address _collateralType,\n    uint256 _collateralValue,\n    uint256 _vaultDebt\n  ) external view returns (uint256 healthFactor);\n\n  function liquidationBonus(uint256 _amount) external view returns (uint256 bonus);\n\n  function applyLiquidationDiscount(uint256 _amount) external view returns (uint256 discountedAmount);\n\n  function isHealthy(\n    address _collateralType,\n    uint256 _collateralValue,\n    uint256 _vaultDebt\n  ) external view returns (bool);\n}\n"
    },
    "contracts/core/governance/interfaces/IGovernanceAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"./IGovernorAlpha.sol\";\nimport \"./ITimelock.sol\";\nimport \"./IVotingEscrow.sol\";\nimport \"../../interfaces/IAccessController.sol\";\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../../liquidityMining/interfaces/IMIMO.sol\";\nimport \"../../liquidityMining/interfaces/IDebtNotifier.sol\";\n\ninterface IGovernanceAddressProvider {\n  function setParallelAddressProvider(IAddressProvider _parallel) external;\n\n  function setMIMO(IMIMO _mimo) external;\n\n  function setDebtNotifier(IDebtNotifier _debtNotifier) external;\n\n  function setGovernorAlpha(IGovernorAlpha _governorAlpha) external;\n\n  function setTimelock(ITimelock _timelock) external;\n\n  function setVotingEscrow(IVotingEscrow _votingEscrow) external;\n\n  function controller() external view returns (IAccessController);\n\n  function parallel() external view returns (IAddressProvider);\n\n  function mimo() external view returns (IMIMO);\n\n  function debtNotifier() external view returns (IDebtNotifier);\n\n  function governorAlpha() external view returns (IGovernorAlpha);\n\n  function timelock() external view returns (ITimelock);\n\n  function votingEscrow() external view returns (IVotingEscrow);\n}\n"
    },
    "contracts/core/liquidityMining/interfaces/ISupplyMiner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\ninterface ISupplyMiner {\n  function baseDebtChanged(address user, uint256 newBaseDebt) external;\n}\n"
    },
    "contracts/core/governance/interfaces/IGovernorAlpha.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\ninterface IGovernorAlpha {\n  /// @notice Possible states that a proposal may be in\n  enum ProposalState { Active, Canceled, Defeated, Succeeded, Queued, Expired, Executed }\n\n  struct Proposal {\n    // Unique id for looking up a proposal\n    uint256 id;\n    // Creator of the proposal\n    address proposer;\n    // The timestamp that the proposal will be available for execution, set once the vote succeeds\n    uint256 eta;\n    // the ordered list of target addresses for calls to be made\n    address[] targets;\n    // The ordered list of values (i.e. msg.value) to be passed to the calls to be made\n    uint256[] values;\n    // The ordered list of function signatures to be called\n    string[] signatures;\n    // The ordered list of calldata to be passed to each call\n    bytes[] calldatas;\n    // The timestamp at which voting begins: holders must delegate their votes prior to this timestamp\n    uint256 startTime;\n    // The timestamp at which voting ends: votes must be cast prior to this timestamp\n    uint256 endTime;\n    // Current number of votes in favor of this proposal\n    uint256 forVotes;\n    // Current number of votes in opposition to this proposal\n    uint256 againstVotes;\n    // Flag marking whether the proposal has been canceled\n    bool canceled;\n    // Flag marking whether the proposal has been executed\n    bool executed;\n    // Receipts of ballots for the entire set of voters\n    mapping(address => Receipt) receipts;\n  }\n\n  /// @notice Ballot receipt record for a voter\n  struct Receipt {\n    // Whether or not a vote has been cast\n    bool hasVoted;\n    // Whether or not the voter supports the proposal\n    bool support;\n    // The number of votes the voter had, which were cast\n    uint256 votes;\n  }\n\n  /// @notice An event emitted when a new proposal is created\n  event ProposalCreated(\n    uint256 id,\n    address proposer,\n    address[] targets,\n    uint256[] values,\n    string[] signatures,\n    bytes[] calldatas,\n    uint256 startTime,\n    uint256 endTime,\n    string description\n  );\n\n  /// @notice An event emitted when a vote has been cast on a proposal\n  event VoteCast(address voter, uint256 proposalId, bool support, uint256 votes);\n\n  /// @notice An event emitted when a proposal has been canceled\n  event ProposalCanceled(uint256 id);\n\n  /// @notice An event emitted when a proposal has been queued in the Timelock\n  event ProposalQueued(uint256 id, uint256 eta);\n\n  /// @notice An event emitted when a proposal has been executed in the Timelock\n  event ProposalExecuted(uint256 id);\n\n  function propose(\n    address[] memory targets,\n    uint256[] memory values,\n    string[] memory signatures,\n    bytes[] memory calldatas,\n    string memory description,\n    uint256 endTime\n  ) external returns (uint256);\n\n  function queue(uint256 proposalId) external;\n\n  function execute(uint256 proposalId) external payable;\n\n  function cancel(uint256 proposalId) external;\n\n  function castVote(uint256 proposalId, bool support) external;\n\n  function getActions(uint256 proposalId)\n    external\n    view\n    returns (\n      address[] memory targets,\n      uint256[] memory values,\n      string[] memory signatures,\n      bytes[] memory calldatas\n    );\n\n  function getReceipt(uint256 proposalId, address voter) external view returns (Receipt memory);\n\n  function state(uint256 proposalId) external view returns (ProposalState);\n\n  function quorumVotes() external view returns (uint256);\n\n  function proposalThreshold() external view returns (uint256);\n}\n"
    },
    "contracts/core/governance/interfaces/ITimelock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.0;\n\ninterface ITimelock {\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint256 indexed newDelay);\n  event CancelTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event ExecuteTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n  event QueueTransaction(\n    bytes32 indexed txHash,\n    address indexed target,\n    uint256 value,\n    string signature,\n    bytes data,\n    uint256 eta\n  );\n\n  function acceptAdmin() external;\n\n  function queueTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external returns (bytes32);\n\n  function cancelTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external;\n\n  function executeTransaction(\n    address target,\n    uint256 value,\n    string calldata signature,\n    bytes calldata data,\n    uint256 eta\n  ) external payable returns (bytes memory);\n\n  function delay() external view returns (uint256);\n\n  function GRACE_PERIOD() external view returns (uint256);\n\n  function queuedTransactions(bytes32 hash) external view returns (bool);\n}\n"
    },
    "contracts/core/governance/interfaces/IVotingEscrow.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../liquidityMining/interfaces/IGenericMiner.sol\";\n\ninterface IVotingEscrow {\n  enum LockAction {\n    CREATE_LOCK,\n    INCREASE_LOCK_AMOUNT,\n    INCREASE_LOCK_TIME\n  }\n\n  struct LockedBalance {\n    uint256 amount;\n    uint256 end;\n  }\n\n  /** Shared Events */\n  event Deposit(address indexed provider, uint256 value, uint256 locktime, LockAction indexed action, uint256 ts);\n  event Withdraw(address indexed provider, uint256 value, uint256 ts);\n  event Expired();\n\n  function createLock(uint256 _value, uint256 _unlockTime) external;\n\n  function increaseLockAmount(uint256 _value) external;\n\n  function increaseLockLength(uint256 _unlockTime) external;\n\n  function withdraw() external;\n\n  function expireContract() external;\n\n  function setMiner(IGenericMiner _miner) external;\n\n  function setMinimumLockTime(uint256 _minimumLockTime) external;\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint256);\n\n  function balanceOf(address _owner) external view returns (uint256);\n\n  function balanceOfAt(address _owner, uint256 _blockTime) external view returns (uint256);\n\n  function stakingToken() external view returns (IERC20);\n}\n"
    },
    "contracts/core/liquidityMining/interfaces/IMIMO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IMIMO is IERC20 {\n  function burn(address account, uint256 amount) external;\n\n  function mint(address account, uint256 amount) external;\n}\n"
    },
    "contracts/core/liquidityMining/interfaces/IGenericMiner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/IAddressProvider.sol\";\nimport \"../../governance/interfaces/IGovernanceAddressProvider.sol\";\n\ninterface IGenericMiner {\n  struct UserInfo {\n    uint256 stake;\n    uint256 accAmountPerShare; // User's accAmountPerShare\n  }\n\n  /// @dev This emit when a users' productivity has changed\n  /// It emits with the user's address and the the value after the change.\n  event StakeIncreased(address indexed user, uint256 stake);\n\n  /// @dev This emit when a users' productivity has changed\n  /// It emits with the user's address and the the value after the change.\n  event StakeDecreased(address indexed user, uint256 stake);\n\n  function releaseMIMO(address _user) external;\n\n  function a() external view returns (IGovernanceAddressProvider);\n\n  function stake(address _user) external view returns (uint256);\n\n  function pendingMIMO(address _user) external view returns (uint256);\n\n  function totalStake() external view returns (uint256);\n\n  function userInfo(address _user) external view returns (UserInfo memory);\n}\n"
    },
    "contracts/proxy/interfaces/IMIMOProxy.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"./IMIMOProxyFactory.sol\";\n\n/// @title IMIMOProxy\n/// @notice Proxy contract to compose transactions on owner's behalf.\ninterface IMIMOProxy {\n  event Execute(address indexed target, bytes data, bytes response);\n\n  function execute(address target, bytes calldata data) external payable returns (bytes memory response);\n\n  function proxyFactory() external returns (IMIMOProxyFactory);\n}\n"
    },
    "contracts/proxy/interfaces/IMIMOProxyGuard.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"./IMIMOProxyFactory.sol\";\n\ninterface IMIMOProxyGuard {\n  event PermissionSet(address indexed envoy, address indexed target, bytes4 selector, bool permission);\n\n  function initialize(address proxyFactory, address proxy) external;\n\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) external;\n\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view returns (bool);\n\n  function getProxy() external view returns (address proxy);\n\n  function getProxyFactory() external view returns (IMIMOProxyFactory proxyFactory);\n}\n"
    },
    "contracts/actions/automated/MIMOAutoAction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./interfaces/IMIMOAutoAction.sol\";\nimport \"../../core/interfaces/IAddressProvider.sol\";\nimport { Errors } from \"../../libraries/Errors.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract MIMOAutoAction is IMIMOAutoAction {\n  using WadRayMath for uint256;\n\n  IAddressProvider public immutable a;\n  IMIMOProxyFactory public immutable proxyFactory;\n\n  mapping(uint256 => AutomatedVault) internal _automatedVaults;\n  mapping(uint256 => uint256) internal _operationTracker;\n\n  constructor(IAddressProvider _a, IMIMOProxyFactory _proxyFactory) {\n    if (address(_a) == address(0) || address(_proxyFactory) == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    a = _a;\n    proxyFactory = _proxyFactory;\n  }\n\n  /**\n    @notice Sets a vault automation parameters\n    @dev Can only be called by vault owner\n    @param vaultId Vault id of the vault to be automated\n    @param autoParams AutomatedVault struct containing all automation parameters\n   */\n  function setAutomation(uint256 vaultId, AutomatedVault calldata autoParams) external override {\n    address vaultOwner = a.vaultsData().vaultOwner(vaultId); // vaultOwner is the owner in vaultsCore\n    if (vaultOwner == address(0)) {\n      revert Errors.VAULT_NOT_INITIALIZED(vaultId);\n    }\n    address mimoProxy = address(proxyFactory.getCurrentProxy(msg.sender));\n\n    // If msg.sender isn't the mimoProxy, msg.sender should own the mimoProxy for the vaultId\n    if (vaultOwner != msg.sender) {\n      if (mimoProxy != vaultOwner) {\n        revert Errors.CALLER_NOT_VAULT_OWNER(mimoProxy, vaultOwner);\n      }\n    }\n    uint256 toVaultMcr = a.config().collateralMinCollateralRatio(autoParams.toCollateral);\n    uint256 maxVarFee = (autoParams.targetRatio.wadDiv(toVaultMcr + autoParams.mcrBuffer) + WadRayMath.WAD).wadDiv(\n      autoParams.targetRatio\n    );\n\n    if (autoParams.varFee >= maxVarFee) {\n      revert Errors.VARIABLE_FEE_TOO_HIGH(maxVarFee, autoParams.varFee);\n    }\n\n    _automatedVaults[vaultId] = autoParams;\n\n    emit AutomationSet(vaultId, autoParams);\n  }\n\n  /**\n    @param vaultId Vault id of the queried vault\n    @return AutomatedVault struct of a specific vault id\n   */\n  function getAutomatedVault(uint256 vaultId) external view override returns (AutomatedVault memory) {\n    return _automatedVaults[vaultId];\n  }\n\n  /**\n    @param vaultId Vault id of the queried vault\n    @return Timestamp of the last performed operation\n   */\n  function getOperationTracker(uint256 vaultId) external view override returns (uint256) {\n    return _operationTracker[vaultId];\n  }\n\n  /**\n    @notice Helper function calculating a vault's net value and LTV ratio\n    @param vaultId Vault id of the queried vault\n    @return vaultRatio Vault collateral value / vault debt\n    @return vaultState VaultState struct of the target vault\n   */\n  function _getVaultStats(uint256 vaultId) internal view returns (uint256 vaultRatio, VaultState memory vaultState) {\n    IAddressProvider _a = a;\n    IVaultsDataProvider vaultsData = _a.vaultsData();\n    IPriceFeed priceFeed = _a.priceFeed();\n\n    uint256 collateralBalance = vaultsData.vaultCollateralBalance(vaultId);\n    address collateralType = vaultsData.vaultCollateralType(vaultId);\n    uint256 collateralValue = priceFeed.convertFrom(collateralType, collateralBalance);\n    uint256 vaultDebt = vaultsData.vaultDebt(vaultId);\n    vaultRatio = vaultDebt == 0 ? type(uint256).max : collateralValue.wadDiv(vaultDebt);\n\n    vaultState = VaultState({ collateralType: collateralType, collateralValue: collateralValue, vaultDebt: vaultDebt });\n  }\n\n  /**\n    @notice Helper function determining if a vault value variation is within vault's management parameters\n    @param autoVault AutomatedVault struct of the vault being rebalanced\n    @param rebalanceValue Rebalance value in stablex\n    @param swapResultValue Collateral value in stablex after swap\n    @return True if value change is below allowedVariation and false if it is above\n   */\n  function _isVaultVariationAllowed(\n    AutomatedVault memory autoVault,\n    uint256 rebalanceValue,\n    uint256 swapResultValue\n  ) internal pure returns (bool) {\n    if (swapResultValue >= rebalanceValue) {\n      return true;\n    }\n\n    uint256 vaultVariation = (rebalanceValue - swapResultValue).wadDiv(rebalanceValue);\n\n    if (vaultVariation > autoVault.allowedVariation) {\n      return false;\n    }\n\n    return true;\n  }\n}\n"
    },
    "contracts/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\n/**\n    @title Errors library\n    @author MIMO\n    @notice Defines the error messages emtted by the different contracts of the MIMO protocol\n */\n\nlibrary Errors {\n  error CANNOT_SET_TO_ADDRESS_ZERO();\n  error INITIATOR_NOT_AUTHORIZED(address actual, address expected);\n  error CALLER_NOT_LENDING_POOL(address actual, address expected);\n  error CANNOT_REPAY_FLASHLOAN();\n  error INVALID_AGGREGATOR();\n  error AGGREGATOR_CALL_FAILED();\n  error EXECUTION_NOT_AUTHORIZED(address owner, address caller, address target, bytes4 selector);\n  error EXECUTION_REVERTED();\n  error NOT_OWNER(address owner, address caller);\n  error OWNER_CHANGED(address originalOwner, address newOwner);\n  error TARGET_INVALID(address target);\n  error CALLER_NOT_VAULT_OWNER(address callerProxy, address vaultOwner);\n  error CALLER_NOT_PROTOCOL_MANAGER();\n  error MANAGER_NOT_LISTED();\n  error VAULT_NOT_UNDER_MANAGEMENT();\n  error CALLER_NOT_SELECTED_MANAGER();\n  error PROXY_ALREADY_EXISTS(address owner);\n  error MAX_OPERATIONS_REACHED();\n  error MINT_AMOUNT_GREATER_THAN_VAULT_DEBT();\n  error VAULT_VALUE_CHANGE_TOO_HIGH();\n  error FINAL_VAULT_RATIO_TOO_LOW(uint256 minRatio, uint256 actualRatio);\n  error VAULT_NOT_AUTOMATED();\n  error VAULT_TRIGGER_RATIO_NOT_REACHED(uint256 actual, uint256 expected);\n  error TARGETS_LENGTH_DIFFERENT_THAN_DATA_LENGTH(uint256 targetsLength, uint256 dataLength);\n  error LOW_LEVEL_CALL_FAILED();\n  error REBALANCE_AMOUNT_CANNOT_BE_ZERO();\n  error VARIABLE_FEE_TOO_HIGH(uint256 maxVarFee, uint256 actualVarFee);\n  error VAULT_NOT_INITIALIZED(uint256 vaultId);\n  error ALREADY_OWNER(address owner, address ownedProxy);\n  error CALLER_NOT_PENDING_OWNER(address caller, address pendingOwner);\n  error UNAUTHORIZED_CALLER();\n  error PAUSED();\n}\n"
    },
    "contracts/libraries/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @notice Provides functions to perform calculations with Wad and Ray units\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers\n * with 27 digits of precision)\n * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.\n **/\nlibrary WadRayMath {\n  // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly\n  uint256 internal constant WAD = 1e18;\n  uint256 internal constant HALF_WAD = 0.5e18;\n\n  uint256 internal constant RAY = 1e27;\n  uint256 internal constant HALF_RAY = 0.5e27;\n\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n  /**\n   * @dev Multiplies two wad, rounding half up to the nearest wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @param b Wad\n   * @return c = a*b, in wad\n   **/\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b\n    assembly {\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, b), HALF_WAD), WAD)\n    }\n  }\n\n  /**\n   * @dev Divides two wad, rounding half up to the nearest wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @param b Wad\n   * @return c = a/b, in wad\n   **/\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - halfB) / WAD\n    assembly {\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, WAD), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @notice Multiplies two ray, rounding half up to the nearest ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @param b Ray\n   * @return c = a raymul b\n   **/\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b\n    assembly {\n      if iszero(or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, b), HALF_RAY), RAY)\n    }\n  }\n\n  /**\n   * @notice Divides two ray, rounding half up to the nearest ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @param b Ray\n   * @return c = a raydiv b\n   **/\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    // to avoid overflow, a <= (type(uint256).max - halfB) / RAY\n    assembly {\n      if or(iszero(b), iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))) {\n        revert(0, 0)\n      }\n\n      c := div(add(mul(a, RAY), div(b, 2)), b)\n    }\n  }\n\n  /**\n   * @dev Casts ray down to wad\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Ray\n   * @return b = a converted to wad, rounded half up to the nearest wad\n   **/\n  function rayToWad(uint256 a) internal pure returns (uint256 b) {\n    assembly {\n      b := div(a, WAD_RAY_RATIO)\n      let remainder := mod(a, WAD_RAY_RATIO)\n      if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) {\n        b := add(b, 1)\n      }\n    }\n  }\n\n  /**\n   * @dev Converts wad up to ray\n   * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328\n   * @param a Wad\n   * @return b = a converted in ray\n   **/\n  function wadToRay(uint256 a) internal pure returns (uint256 b) {\n    // to avoid overflow, b/WAD_RAY_RATIO == a\n    assembly {\n      b := mul(a, WAD_RAY_RATIO)\n\n      if iszero(eq(div(b, WAD_RAY_RATIO), a)) {\n        revert(0, 0)\n      }\n    }\n  }\n}\n"
    },
    "contracts/actions/automated/MIMOAutoRebalance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./MIMOAutoAction.sol\";\nimport \"./interfaces/IMIMOAutoRebalance.sol\";\nimport \"../MIMOFlashLoan.sol\";\nimport \"../MIMOPausable.sol\";\nimport \"../interfaces/IMIMORebalance.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\nimport { Errors } from \"../../libraries/Errors.sol\";\n\n/**\n  Rebalance value is calculated by the formula below :\n\n             targetRatio * (vaultDebt + fixedFee) - collateralValue\n      ----------------------------------------------------------------------\n          targetRatio / (mcrB + mcrBuffer) - targetRatio * variableFee - 1 \n */\n\ncontract MIMOAutoRebalance is MIMOPausable, MIMOAutoAction, MIMOFlashLoan, ReentrancyGuard, IMIMOAutoRebalance {\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  uint256 public constant ROUNDING_BUFFER = 1e15;\n\n  address public immutable mimoRebalance;\n\n  constructor(\n    IAddressProvider _a,\n    IPool _lendingPool,\n    IMIMOProxyFactory _proxyFactory,\n    address _mimoRebalance\n  ) MIMOAutoAction(_a, _proxyFactory) MIMOFlashLoan(_lendingPool) {\n    if (_mimoRebalance == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    mimoRebalance = _mimoRebalance;\n  }\n\n  /**\n    @notice Perform a rebalance on a vault on behalf of vault owner\n    @notice Vault must have been created though a MIMOProxy\n    @dev Reverts if operation results in vault value change above allowed variation or in vault ratio lower than min \n    ratio\n    @param vaultId Vault id of the vault to rebalance\n    @param swapData SwapData struct containing aggegator swap parameters\n   */\n  function rebalance(uint256 vaultId, IMIMOSwap.SwapData calldata swapData)\n    external\n    override\n    whenNotPaused\n    nonReentrant\n  {\n    AutomatedVault memory autoVault = _automatedVaults[vaultId];\n\n    (uint256 vaultARatioBefore, VaultState memory vaultAState) = _getVaultStats(vaultId);\n\n    _preRebalanceChecks(autoVault, vaultId, vaultARatioBefore);\n\n    IVaultsDataProvider vaultsData = a.vaultsData();\n    address vaultOwner = vaultsData.vaultOwner(vaultId);\n    uint256 vaultBId = vaultsData.vaultId(address(autoVault.toCollateral), vaultOwner);\n    uint256 vaultBBalanceBefore = vaultsData.vaultCollateralBalance(vaultBId);\n\n    (IMIMORebalance.RebalanceData memory rbData, FlashLoanData memory flData, uint256 autoFee) = _getRebalanceParams(\n      autoVault,\n      vaultAState,\n      IERC20(autoVault.toCollateral),\n      vaultId\n    );\n\n    _takeFlashLoan(flData, abi.encode(vaultOwner, autoFee, rbData, swapData));\n    _postRebalanceChecks(autoVault, flData.amount, vaultBBalanceBefore, vaultId, vaultOwner, vaultsData);\n\n    _operationTracker[vaultId] = block.timestamp;\n\n    IERC20(a.stablex()).safeTransfer(msg.sender, autoFee);\n  }\n\n  /**\n    @notice Routes a call from a flashloan pool to a leverage or rebalance operation\n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the reblanced asset\n    @param amounts Uint array with one element corresponding to the amount of the rebalanced asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, RebalanceData struct and SwapData struct\n    @return True if success and False if failed\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (\n      address mimoProxy,\n      uint256 managerFee,\n      IMIMORebalance.RebalanceData memory rbData,\n      IMIMOSwap.SwapData memory swapData\n    ) = abi.decode(params, (address, uint256, IMIMORebalance.RebalanceData, IMIMOSwap.SwapData));\n\n    if (initiator != address(this)) {\n      revert Errors.INITIATOR_NOT_AUTHORIZED(initiator, address(this));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert Errors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 fromCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    fromCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      mimoRebalance,\n      abi.encodeWithSignature(\n        \"rebalanceOperation(address,uint256,uint256,uint256,(address,uint256,uint256),(uint256,bytes))\",\n        fromCollateral,\n        amount,\n        flashloanRepayAmount,\n        managerFee,\n        rbData,\n        swapData\n      )\n    );\n\n    fromCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Getter function returning rebalance amounts for specific vault id\n    @param vaultId Vault id of the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @return rebalanceAmount Amount to rebalance\n    @return mintAmount Amount to mint on vault B\n    @return autoFee Automation fee\n   */\n  function getAmounts(uint256 vaultId, address toCollateral)\n    external\n    view\n    override\n    returns (\n      uint256 rebalanceAmount,\n      uint256 mintAmount,\n      uint256 autoFee\n    )\n  {\n    (, VaultState memory vaultState) = _getVaultStats(vaultId);\n    return _getAmounts(_automatedVaults[vaultId], vaultState, toCollateral);\n  }\n\n  /**\n    @notice Helper function calculating the amount to rebalance from vault A and to mint from vault B with rebalnce \n    formula\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultState VaultState struct of the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @return rebalanceAmount Amount to rebalance\n    @return mintAmount Amount to mint on vault b\n    @return autoFee Automation fee\n   */\n  function _getAmounts(\n    AutomatedVault memory autoVault,\n    VaultState memory vaultState,\n    address toCollateral\n  )\n    internal\n    view\n    returns (\n      uint256 rebalanceAmount,\n      uint256 mintAmount,\n      uint256 autoFee\n    )\n  {\n    IAddressProvider _a = a;\n\n    uint256 targetRatio = autoVault.targetRatio + ROUNDING_BUFFER; // add 0.1% to account for rounding\n    uint256 toVaultMcr = _a.config().collateralMinCollateralRatio(address(toCollateral));\n    uint256 rebalanceValue = (targetRatio.wadMul(vaultState.vaultDebt + autoVault.fixedFee) -\n      vaultState.collateralValue).wadDiv(\n        (targetRatio.wadDiv(toVaultMcr + autoVault.mcrBuffer) - targetRatio.wadMul(autoVault.varFee) - WadRayMath.WAD)\n      );\n\n    autoFee = autoVault.fixedFee + rebalanceValue.wadMul(autoVault.varFee);\n    rebalanceAmount = _a.priceFeed().convertTo(vaultState.collateralType, rebalanceValue);\n    mintAmount = rebalanceValue.wadDiv(toVaultMcr + autoVault.mcrBuffer) - autoFee;\n  }\n\n  /**\n    @notice Helper function formatting FlashloanData and RebalanceData parameters\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultState VaultState struct of the vault to rebalance\n    @param toCollateral Collateral to rebalance to\n    @param vaultId Vault id of the vault to rebalance\n    @return rbData RebalanceData struct\n    @return flData FlashloanData struct\n    @return autoFee Automation fee\n   */\n  function _getRebalanceParams(\n    AutomatedVault memory autoVault,\n    VaultState memory vaultState,\n    IERC20 toCollateral,\n    uint256 vaultId\n  )\n    internal\n    view\n    returns (\n      IMIMORebalance.RebalanceData memory rbData,\n      FlashLoanData memory flData,\n      uint256 autoFee\n    )\n  {\n    (uint256 rebalanceAmount, uint256 mintAmount, uint256 _autoFee) = _getAmounts(\n      autoVault,\n      vaultState,\n      address(toCollateral)\n    );\n\n    autoFee = _autoFee;\n    rbData = IMIMORebalance.RebalanceData({ toCollateral: toCollateral, vaultId: vaultId, mintAmount: mintAmount });\n    flData = FlashLoanData({ asset: vaultState.collateralType, proxyAction: address(this), amount: rebalanceAmount });\n  }\n\n  /**\n    @notice Helper function performing pre rebalance operation sanity checks\n    @dev Checks that :\n      - Vault is automated\n      - Maximum daily operations has not been exceeded\n      - Vault is below the trigger ratio\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param vaultId Vault id of the vault to rebalance\n    @param vaultARatio Collateral to debt ratio of the vault to rebalance\n   */\n  function _preRebalanceChecks(\n    AutomatedVault memory autoVault,\n    uint256 vaultId,\n    uint256 vaultARatio\n  ) internal view {\n    if (!autoVault.isAutomated) {\n      revert Errors.VAULT_NOT_AUTOMATED();\n    }\n    if (_operationTracker[vaultId] > block.timestamp - 1 days) {\n      revert Errors.MAX_OPERATIONS_REACHED();\n    }\n    if (vaultARatio > autoVault.triggerRatio) {\n      revert Errors.VAULT_TRIGGER_RATIO_NOT_REACHED(vaultARatio, autoVault.triggerRatio);\n    }\n  }\n\n  /**\n    @notice Helper function performing post rebalance operation sanity checks\n    @dev Checks that :\n     - Rebalance swap slippage is below allowedVaration\n     - Vault ratio is above targetRatio\n    @param autoVault AutomatedVault struct of the vault to rebalance\n    @param rebalanceAmount Rebalanced amount\n    @param vaultBBalanceBefore Collateral balance of the vault to be rebalanced to before the rebalance operation\n    @param vaultId Vault id of the vault to rebalance\n    @param vaultOwner Rebalanced vault owner\n    @param vaultsData Cached VaultsDataProvider interface for gas saving\n   */\n  function _postRebalanceChecks(\n    AutomatedVault memory autoVault,\n    uint256 rebalanceAmount,\n    uint256 vaultBBalanceBefore,\n    uint256 vaultId,\n    address vaultOwner,\n    IVaultsDataProvider vaultsData\n  ) internal view {\n    IPriceFeed priceFeed = a.priceFeed();\n    address fromCollateral = vaultsData.vaultCollateralType(vaultId);\n    uint256 rebalanceValue = priceFeed.convertFrom(fromCollateral, rebalanceAmount);\n    uint256 vaultBId = vaultsData.vaultId(autoVault.toCollateral, vaultOwner);\n    uint256 vaultBBalanceAfter = vaultsData.vaultCollateralBalance(vaultBId);\n    uint256 swapResultValue = priceFeed.convertFrom(autoVault.toCollateral, vaultBBalanceAfter - vaultBBalanceBefore);\n\n    if (!_isVaultVariationAllowed(autoVault, rebalanceValue, swapResultValue)) {\n      revert Errors.VAULT_VALUE_CHANGE_TOO_HIGH();\n    }\n\n    (uint256 vaultARatio, ) = _getVaultStats(vaultId);\n\n    if (vaultARatio < autoVault.targetRatio) {\n      revert Errors.FINAL_VAULT_RATIO_TOO_LOW(autoVault.targetRatio, vaultARatio);\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/actions/automated/interfaces/IMIMOAutoRebalance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IMIMOAutoAction.sol\";\nimport \"../../interfaces/IMIMOSwap.sol\";\n\ninterface IMIMOAutoRebalance is IMIMOAutoAction {\n  function rebalance(uint256 vaultId, IMIMOSwap.SwapData calldata swapData) external;\n\n  function getAmounts(uint256 vaultId, address toCollateral)\n    external\n    returns (\n      uint256 rebalanceAmount,\n      uint256 mintAmount,\n      uint256 autoFee\n    );\n}\n"
    },
    "contracts/actions/MIMOFlashLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IPool } from \"@aave/core-v3/contracts/interfaces/IPool.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport \"./interfaces/IMIMOFlashLoan.sol\";\n\nabstract contract MIMOFlashLoan is IMIMOFlashLoan {\n  using SafeERC20 for IERC20;\n\n  IPool public immutable lendingPool;\n\n  constructor(IPool _lendingPool) {\n    if (address(_lendingPool) == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    lendingPool = _lendingPool;\n  }\n\n  /**\n    @notice Helper function to format arguments to take a flashloan\n    @param flData FlashloanData struct containing flashloan asset, amount and params\n   */\n  function _takeFlashLoan(FlashLoanData memory flData, bytes memory params) internal {\n    address[] memory assets = new address[](1);\n    uint256[] memory amounts = new uint256[](1);\n    uint256[] memory modes = new uint256[](1);\n    (assets[0], amounts[0]) = (flData.asset, flData.amount);\n\n    lendingPool.flashLoan(flData.proxyAction, assets, amounts, modes, flData.proxyAction, params, 0);\n  }\n}\n"
    },
    "contracts/actions/MIMOPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./interfaces/IMIMOPausable.sol\";\nimport \"../libraries/BoringOwnable.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\ncontract MIMOPausable is IMIMOPausable, BoringOwnable {\n  bool private _paused;\n\n  modifier whenNotPaused() virtual {\n    if (_paused) {\n      revert Errors.PAUSED();\n    }\n    _;\n  }\n\n  function pause() external override onlyOwner {\n    _paused = true;\n  }\n\n  function unpause() external override onlyOwner {\n    _paused = false;\n  }\n\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n}\n"
    },
    "contracts/actions/interfaces/IMIMORebalance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./IMIMOSwap.sol\";\nimport \"./IMIMOProxyAction.sol\";\nimport \"../../proxy/interfaces/IMIMOProxyFactory.sol\";\n\ninterface IMIMORebalance is IMIMOProxyAction, IMIMOSwap {\n  struct RebalanceData {\n    IERC20 toCollateral;\n    uint256 vaultId;\n    uint256 mintAmount;\n  }\n\n  function rebalanceOperation(\n    IERC20 fromCollateral,\n    uint256 swapAmount,\n    uint256 flashloanRepayAmount,\n    uint256 fee,\n    RebalanceData calldata rbData,\n    SwapData calldata swapData\n  ) external;\n\n  function proxyFactory() external view returns (IMIMOProxyFactory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/actions/interfaces/IMIMOSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../../core/dex/interfaces/IDexAddressProvider.sol\";\n\ninterface IMIMOSwap {\n  struct SwapData {\n    uint256 dexIndex;\n    bytes dexTxData;\n  }\n\n  function dexAP() external returns (IDexAddressProvider);\n}\n"
    },
    "contracts/core/dex/interfaces/IDexAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/IAddressProvider.sol\";\n\ninterface IDexAddressProvider {\n  struct Dex {\n    address proxy;\n    address router;\n  }\n\n  event DexSet(uint256 index, address proxy, address router);\n\n  function setDexMapping(\n    uint256 _index,\n    address _proxy,\n    address _dex\n  ) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function getDex(uint256 index) external view returns (address, address);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\nimport {IPoolAddressesProvider} from './IPoolAddressesProvider.sol';\nimport {DataTypes} from '../protocol/libraries/types/DataTypes.sol';\n\n/**\n * @title IPool\n * @author Aave\n * @notice Defines the basic interface for an Aave Pool.\n **/\ninterface IPool {\n  /**\n   * @dev Emitted on mintUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\n   * @param amount The amount of supplied assets\n   * @param referralCode The referral code used\n   **/\n  event MintUnbacked(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on backUnbacked()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param backer The address paying for the backing\n   * @param amount The amount added as backing\n   * @param fee The amount paid in fees\n   **/\n  event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);\n\n  /**\n   * @dev Emitted on supply()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address initiating the supply\n   * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\n   * @param amount The amount supplied\n   * @param referralCode The referral code used\n   **/\n  event Supply(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on withdraw()\n   * @param reserve The address of the underlying asset being withdrawn\n   * @param user The address initiating the withdrawal, owner of aTokens\n   * @param to The address that will receive the underlying\n   * @param amount The amount to be withdrawn\n   **/\n  event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);\n\n  /**\n   * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n   * @param reserve The address of the underlying asset being borrowed\n   * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n   * initiator of the transaction on flashLoan()\n   * @param onBehalfOf The address that will be getting the debt\n   * @param amount The amount borrowed out\n   * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\n   * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\n   * @param referralCode The referral code used\n   **/\n  event Borrow(\n    address indexed reserve,\n    address user,\n    address indexed onBehalfOf,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 borrowRate,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted on repay()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The beneficiary of the repayment, getting his debt reduced\n   * @param repayer The address of the user initiating the repay(), providing the funds\n   * @param amount The amount repaid\n   * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\n   **/\n  event Repay(\n    address indexed reserve,\n    address indexed user,\n    address indexed repayer,\n    uint256 amount,\n    bool useATokens\n  );\n\n  /**\n   * @dev Emitted on swapBorrowRateMode()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user swapping his rate mode\n   * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\n   **/\n  event SwapBorrowRateMode(\n    address indexed reserve,\n    address indexed user,\n    DataTypes.InterestRateMode interestRateMode\n  );\n\n  /**\n   * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\n   * @param asset The address of the underlying asset of the reserve\n   * @param totalDebt The total isolation mode debt for the reserve\n   */\n  event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);\n\n  /**\n   * @dev Emitted when the user selects a certain asset category for eMode\n   * @param user The address of the user\n   * @param categoryId The category id\n   **/\n  event UserEModeSet(address indexed user, uint8 categoryId);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on setUserUseReserveAsCollateral()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user enabling the usage as collateral\n   **/\n  event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on rebalanceStableBorrowRate()\n   * @param reserve The address of the underlying asset of the reserve\n   * @param user The address of the user for which the rebalance has been executed\n   **/\n  event RebalanceStableBorrowRate(address indexed reserve, address indexed user);\n\n  /**\n   * @dev Emitted on flashLoan()\n   * @param target The address of the flash loan receiver contract\n   * @param initiator The address initiating the flash loan\n   * @param asset The address of the asset being flash borrowed\n   * @param amount The amount flash borrowed\n   * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\n   * @param premium The fee flash borrowed\n   * @param referralCode The referral code used\n   **/\n  event FlashLoan(\n    address indexed target,\n    address initiator,\n    address indexed asset,\n    uint256 amount,\n    DataTypes.InterestRateMode interestRateMode,\n    uint256 premium,\n    uint16 indexed referralCode\n  );\n\n  /**\n   * @dev Emitted when a borrower is liquidated.\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\n   * @param liquidator The address of the liquidator\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  event LiquidationCall(\n    address indexed collateralAsset,\n    address indexed debtAsset,\n    address indexed user,\n    uint256 debtToCover,\n    uint256 liquidatedCollateralAmount,\n    address liquidator,\n    bool receiveAToken\n  );\n\n  /**\n   * @dev Emitted when the state of a reserve is updated.\n   * @param reserve The address of the underlying asset of the reserve\n   * @param liquidityRate The next liquidity rate\n   * @param stableBorrowRate The next stable borrow rate\n   * @param variableBorrowRate The next variable borrow rate\n   * @param liquidityIndex The next liquidity index\n   * @param variableBorrowIndex The next variable borrow index\n   **/\n  event ReserveDataUpdated(\n    address indexed reserve,\n    uint256 liquidityRate,\n    uint256 stableBorrowRate,\n    uint256 variableBorrowRate,\n    uint256 liquidityIndex,\n    uint256 variableBorrowIndex\n  );\n\n  /**\n   * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\n   * @param reserve The address of the reserve\n   * @param amountMinted The amount minted to the treasury\n   **/\n  event MintedToTreasury(address indexed reserve, uint256 amountMinted);\n\n  /**\n   * @dev Mints an `amount` of aTokens to the `onBehalfOf`\n   * @param asset The address of the underlying asset to mint\n   * @param amount The amount to mint\n   * @param onBehalfOf The address that will receive the aTokens\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function mintUnbacked(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @dev Back the current unbacked underlying with `amount` and pay `fee`.\n   * @param asset The address of the underlying asset to back\n   * @param amount The amount to back\n   * @param fee The amount paid in fees\n   **/\n  function backUnbacked(\n    address asset,\n    uint256 amount,\n    uint256 fee\n  ) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function supply(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Supply with transfer approval of asset to be supplied done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   **/\n  function supplyWithPermit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external;\n\n  /**\n   * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n   * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n   * @param asset The address of the underlying asset to withdraw\n   * @param amount The underlying amount to be withdrawn\n   *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n   * @param to The address that will receive the underlying, same as msg.sender if the user\n   *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n   *   different wallet\n   * @return The final amount withdrawn\n   **/\n  function withdraw(\n    address asset,\n    uint256 amount,\n    address to\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n   * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\n   * corresponding debt token (StableDebtToken or VariableDebtToken)\n   * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n   *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n   * @param asset The address of the underlying asset to borrow\n   * @param amount The amount to be borrowed\n   * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\n   * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n   * if he has been given credit delegation allowance\n   **/\n  function borrow(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    uint16 referralCode,\n    address onBehalfOf\n  ) external;\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n   * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @return The final amount repaid\n   **/\n  function repay(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf\n  ) external returns (uint256);\n\n  /**\n   * @notice Repay with transfer approval of asset to be repaid done via permit function\n   * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n   * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n   * other borrower whose debt should be removed\n   * @param deadline The deadline timestamp that the permit is valid\n   * @param permitV The V parameter of ERC712 permit sig\n   * @param permitR The R parameter of ERC712 permit sig\n   * @param permitS The S parameter of ERC712 permit sig\n   * @return The final amount repaid\n   **/\n  function repayWithPermit(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode,\n    address onBehalfOf,\n    uint256 deadline,\n    uint8 permitV,\n    bytes32 permitR,\n    bytes32 permitS\n  ) external returns (uint256);\n\n  /**\n   * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\n   * equivalent debt tokens\n   * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\n   * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\n   * balance is not enough to cover the whole debt\n   * @param asset The address of the borrowed underlying asset previously borrowed\n   * @param amount The amount to repay\n   * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n   * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n   * @return The final amount repaid\n   **/\n  function repayWithATokens(\n    address asset,\n    uint256 amount,\n    uint256 interestRateMode\n  ) external returns (uint256);\n\n  /**\n   * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\n   * @param asset The address of the underlying asset borrowed\n   * @param interestRateMode The rate mode that the user wants to swap to: 1 for Stable, 2 for Variable\n   **/\n  function swapBorrowRateMode(address asset, uint256 interestRateMode) external;\n\n  /**\n   * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n   * - Users can be rebalanced if the following conditions are satisfied:\n   *     1. Usage ratio is above 95%\n   *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\n   *        much has been borrowed at a stable rate and suppliers are not earning enough\n   * @param asset The address of the underlying asset borrowed\n   * @param user The address of the user to be rebalanced\n   **/\n  function rebalanceStableBorrowRate(address asset, address user) external;\n\n  /**\n   * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\n   * @param asset The address of the underlying asset supplied\n   * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\n   **/\n  function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;\n\n  /**\n   * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n   * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n   *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n   * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n   * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n   * @param user The address of the borrower getting liquidated\n   * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n   * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\n   * to receive the underlying collateral asset directly\n   **/\n  function liquidationCall(\n    address collateralAsset,\n    address debtAsset,\n    address user,\n    uint256 debtToCover,\n    bool receiveAToken\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\n   * @param assets The addresses of the assets being flash-borrowed\n   * @param amounts The amounts of the assets being flash-borrowed\n   * @param interestRateModes Types of the debt to open if the flash loan is not returned:\n   *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n   *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n   * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\n   * as long as the amount taken plus a fee is returned.\n   * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\n   * into consideration. For further details please visit https://developers.aave.com\n   * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\n   * @param asset The address of the asset being flash-borrowed\n   * @param amount The amount of the asset being flash-borrowed\n   * @param params Variadic packed params to pass to the receiver as extra information\n   * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function flashLoanSimple(\n    address receiverAddress,\n    address asset,\n    uint256 amount,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  /**\n   * @notice Returns the user account data across all the reserves\n   * @param user The address of the user\n   * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\n   * @return totalDebtBase The total debt of the user in the base currency used by the price feed\n   * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\n   * @return currentLiquidationThreshold The liquidation threshold of the user\n   * @return ltv The loan to value of The user\n   * @return healthFactor The current health factor of the user\n   **/\n  function getUserAccountData(address user)\n    external\n    view\n    returns (\n      uint256 totalCollateralBase,\n      uint256 totalDebtBase,\n      uint256 availableBorrowsBase,\n      uint256 currentLiquidationThreshold,\n      uint256 ltv,\n      uint256 healthFactor\n    );\n\n  /**\n   * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\n   * interest rate strategy\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param aTokenAddress The address of the aToken that will be assigned to the reserve\n   * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\n   * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\n   * @param interestRateStrategyAddress The address of the interest rate strategy contract\n   **/\n  function initReserve(\n    address asset,\n    address aTokenAddress,\n    address stableDebtAddress,\n    address variableDebtAddress,\n    address interestRateStrategyAddress\n  ) external;\n\n  /**\n   * @notice Drop a reserve\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   **/\n  function dropReserve(address asset) external;\n\n  /**\n   * @notice Updates the address of the interest rate strategy contract\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param rateStrategyAddress The address of the interest rate strategy contract\n   **/\n  function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress)\n    external;\n\n  /**\n   * @notice Sets the configuration bitmap of the reserve as a whole\n   * @dev Only callable by the PoolConfigurator contract\n   * @param asset The address of the underlying asset of the reserve\n   * @param configuration The new configuration bitmap\n   **/\n  function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration)\n    external;\n\n  /**\n   * @notice Returns the configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The configuration of the reserve\n   **/\n  function getConfiguration(address asset)\n    external\n    view\n    returns (DataTypes.ReserveConfigurationMap memory);\n\n  /**\n   * @notice Returns the configuration of the user across all the reserves\n   * @param user The user address\n   * @return The configuration of the user\n   **/\n  function getUserConfiguration(address user)\n    external\n    view\n    returns (DataTypes.UserConfigurationMap memory);\n\n  /**\n   * @notice Returns the normalized income normalized income of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve's normalized income\n   */\n  function getReserveNormalizedIncome(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the normalized variable debt per unit of asset\n   * @param asset The address of the underlying asset of the reserve\n   * @return The reserve normalized variable debt\n   */\n  function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);\n\n  /**\n   * @notice Returns the state and configuration of the reserve\n   * @param asset The address of the underlying asset of the reserve\n   * @return The state and configuration data of the reserve\n   **/\n  function getReserveData(address asset) external view returns (DataTypes.ReserveData memory);\n\n  /**\n   * @notice Validates and finalizes an aToken transfer\n   * @dev Only callable by the overlying aToken of the `asset`\n   * @param asset The address of the underlying asset of the aToken\n   * @param from The user from which the aTokens are transferred\n   * @param to The user receiving the aTokens\n   * @param amount The amount being transferred/withdrawn\n   * @param balanceFromBefore The aToken balance of the `from` user before the transfer\n   * @param balanceToBefore The aToken balance of the `to` user before the transfer\n   */\n  function finalizeTransfer(\n    address asset,\n    address from,\n    address to,\n    uint256 amount,\n    uint256 balanceFromBefore,\n    uint256 balanceToBefore\n  ) external;\n\n  /**\n   * @notice Returns the list of the initialized reserves\n   * @dev It does not include dropped reserves\n   * @return The addresses of the reserves\n   **/\n  function getReservesList() external view returns (address[] memory);\n\n  /**\n   * @notice Returns the PoolAddressesProvider connected to this contract\n   * @return The address of the PoolAddressesProvider\n   **/\n  function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);\n\n  /**\n   * @notice Updates the protocol fee on the bridging\n   * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\n   */\n  function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\n\n  /**\n   * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\n   * - A part is sent to aToken holders as extra, one time accumulated interest\n   * - A part is collected by the protocol treasury\n   * @dev The total premium is calculated on the total borrowed amount\n   * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\n   * @dev Only callable by the PoolConfigurator contract\n   * @param flashLoanPremiumTotal The total premium, expressed in bps\n   * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\n   */\n  function updateFlashloanPremiums(\n    uint128 flashLoanPremiumTotal,\n    uint128 flashLoanPremiumToProtocol\n  ) external;\n\n  /**\n   * @notice Configures a new category for the eMode.\n   * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\n   * The category 0 is reserved as it's the default for volatile assets\n   * @param id The id of the category\n   * @param config The configuration of the category\n   */\n  function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;\n\n  /**\n   * @notice Returns the data of an eMode category\n   * @param id The id of the category\n   * @return The configuration data of the category\n   */\n  function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);\n\n  /**\n   * @notice Allows a user to use the protocol in eMode\n   * @param categoryId The id of the category\n   */\n  function setUserEMode(uint8 categoryId) external;\n\n  /**\n   * @notice Returns the eMode the user is using\n   * @param user The address of the user\n   * @return The eMode id\n   */\n  function getUserEMode(address user) external view returns (uint256);\n\n  /**\n   * @notice Resets the isolation mode total debt of the given asset to zero\n   * @dev It requires the given asset has zero debt ceiling\n   * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\n   */\n  function resetIsolationModeTotalDebt(address asset) external;\n\n  /**\n   * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\n   * @return The percentage of available liquidity to borrow, expressed in bps\n   */\n  function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);\n\n  /**\n   * @notice Returns the total fee on flash loans\n   * @return The total fee on flashloans\n   */\n  function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\n\n  /**\n   * @notice Returns the part of the bridge fees sent to protocol\n   * @return The bridge fee sent to the protocol treasury\n   */\n  function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\n\n  /**\n   * @notice Returns the part of the flashloan fees sent to protocol\n   * @return The flashloan fee sent to the protocol treasury\n   */\n  function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\n\n  /**\n   * @notice Returns the maximum number of reserves supported to be listed in this Pool\n   * @return The maximum number of reserves supported\n   */\n  function MAX_NUMBER_RESERVES() external view returns (uint16);\n\n  /**\n   * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\n   * @param assets The list of reserves for which the minting needs to be executed\n   **/\n  function mintToTreasury(address[] calldata assets) external;\n\n  /**\n   * @notice Rescue and transfer tokens locked in this contract\n   * @param token The address of the token\n   * @param to The address of the recipient\n   * @param amount The amount of token to transfer\n   */\n  function rescueTokens(\n    address token,\n    address to,\n    uint256 amount\n  ) external;\n\n  /**\n   * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n   * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\n   * @dev Deprecated: Use the `supply` function instead\n   * @param asset The address of the underlying asset to supply\n   * @param amount The amount to be supplied\n   * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n   *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n   *   is a different wallet\n   * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n   *   0 if the action is executed directly by the user, without any middle-man\n   **/\n  function deposit(\n    address asset,\n    uint256 amount,\n    address onBehalfOf,\n    uint16 referralCode\n  ) external;\n}\n"
    },
    "contracts/actions/interfaces/IMIMOFlashLoan.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IPool } from \"@aave/core-v3/contracts/interfaces/IPool.sol\";\n\nimport \"./IMIMOProxyAction.sol\";\nimport \"../../core/interfaces/IAddressProvider.sol\";\n\ninterface IMIMOFlashLoan {\n  struct FlashLoanData {\n    address asset;\n    address proxyAction;\n    uint256 amount;\n  }\n\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external returns (bool);\n\n  function lendingPool() external returns (IPool);\n}\n"
    },
    "@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\npragma solidity 0.8.10;\n\n/**\n * @title IPoolAddressesProvider\n * @author Aave\n * @notice Defines the basic interface for a Pool Addresses Provider.\n **/\ninterface IPoolAddressesProvider {\n  /**\n   * @dev Emitted when the market identifier is updated.\n   * @param oldMarketId The old id of the market\n   * @param newMarketId The new id of the market\n   */\n  event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\n\n  /**\n   * @dev Emitted when the pool is updated.\n   * @param oldAddress The old address of the Pool\n   * @param newAddress The new address of the Pool\n   */\n  event PoolUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool configurator is updated.\n   * @param oldAddress The old address of the PoolConfigurator\n   * @param newAddress The new address of the PoolConfigurator\n   */\n  event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle is updated.\n   * @param oldAddress The old address of the PriceOracle\n   * @param newAddress The new address of the PriceOracle\n   */\n  event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL manager is updated.\n   * @param oldAddress The old address of the ACLManager\n   * @param newAddress The new address of the ACLManager\n   */\n  event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the ACL admin is updated.\n   * @param oldAddress The old address of the ACLAdmin\n   * @param newAddress The new address of the ACLAdmin\n   */\n  event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the price oracle sentinel is updated.\n   * @param oldAddress The old address of the PriceOracleSentinel\n   * @param newAddress The new address of the PriceOracleSentinel\n   */\n  event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the pool data provider is updated.\n   * @param oldAddress The old address of the PoolDataProvider\n   * @param newAddress The new address of the PoolDataProvider\n   */\n  event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when a new proxy is created.\n   * @param id The identifier of the proxy\n   * @param proxyAddress The address of the created proxy contract\n   * @param implementationAddress The address of the implementation contract\n   */\n  event ProxyCreated(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address indexed implementationAddress\n  );\n\n  /**\n   * @dev Emitted when a new non-proxied contract address is registered.\n   * @param id The identifier of the contract\n   * @param oldAddress The address of the old contract\n   * @param newAddress The address of the new contract\n   */\n  event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);\n\n  /**\n   * @dev Emitted when the implementation of the proxy registered with id is updated\n   * @param id The identifier of the contract\n   * @param proxyAddress The address of the proxy contract\n   * @param oldImplementationAddress The address of the old implementation contract\n   * @param newImplementationAddress The address of the new implementation contract\n   */\n  event AddressSetAsProxy(\n    bytes32 indexed id,\n    address indexed proxyAddress,\n    address oldImplementationAddress,\n    address indexed newImplementationAddress\n  );\n\n  /**\n   * @notice Returns the id of the Aave market to which this contract points to.\n   * @return The market id\n   **/\n  function getMarketId() external view returns (string memory);\n\n  /**\n   * @notice Associates an id with a specific PoolAddressesProvider.\n   * @dev This can be used to create an onchain registry of PoolAddressesProviders to\n   * identify and validate multiple Aave markets.\n   * @param newMarketId The market id\n   */\n  function setMarketId(string calldata newMarketId) external;\n\n  /**\n   * @notice Returns an address by its identifier.\n   * @dev The returned address might be an EOA or a contract, potentially proxied\n   * @dev It returns ZERO if there is no registered address with the given id\n   * @param id The id\n   * @return The address of the registered for the specified id\n   */\n  function getAddress(bytes32 id) external view returns (address);\n\n  /**\n   * @notice General function to update the implementation of a proxy registered with\n   * certain `id`. If there is no proxy registered, it will instantiate one and\n   * set as implementation the `newImplementationAddress`.\n   * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\n   * setter function, in order to avoid unexpected consequences\n   * @param id The id\n   * @param newImplementationAddress The address of the new implementation\n   */\n  function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;\n\n  /**\n   * @notice Sets an address for an id replacing the address saved in the addresses map.\n   * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\n   * @param id The id\n   * @param newAddress The address to set\n   */\n  function setAddress(bytes32 id, address newAddress) external;\n\n  /**\n   * @notice Returns the address of the Pool proxy.\n   * @return The Pool proxy address\n   **/\n  function getPool() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the Pool, or creates a proxy\n   * setting the new `pool` implementation when the function is called for the first time.\n   * @param newPoolImpl The new Pool implementation\n   **/\n  function setPoolImpl(address newPoolImpl) external;\n\n  /**\n   * @notice Returns the address of the PoolConfigurator proxy.\n   * @return The PoolConfigurator proxy address\n   **/\n  function getPoolConfigurator() external view returns (address);\n\n  /**\n   * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\n   * setting the new `PoolConfigurator` implementation when the function is called for the first time.\n   * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\n   **/\n  function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\n\n  /**\n   * @notice Returns the address of the price oracle.\n   * @return The address of the PriceOracle\n   */\n  function getPriceOracle() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle.\n   * @param newPriceOracle The address of the new PriceOracle\n   */\n  function setPriceOracle(address newPriceOracle) external;\n\n  /**\n   * @notice Returns the address of the ACL manager.\n   * @return The address of the ACLManager\n   */\n  function getACLManager() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL manager.\n   * @param newAclManager The address of the new ACLManager\n   **/\n  function setACLManager(address newAclManager) external;\n\n  /**\n   * @notice Returns the address of the ACL admin.\n   * @return The address of the ACL admin\n   */\n  function getACLAdmin() external view returns (address);\n\n  /**\n   * @notice Updates the address of the ACL admin.\n   * @param newAclAdmin The address of the new ACL admin\n   */\n  function setACLAdmin(address newAclAdmin) external;\n\n  /**\n   * @notice Returns the address of the price oracle sentinel.\n   * @return The address of the PriceOracleSentinel\n   */\n  function getPriceOracleSentinel() external view returns (address);\n\n  /**\n   * @notice Updates the address of the price oracle sentinel.\n   * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\n   **/\n  function setPriceOracleSentinel(address newPriceOracleSentinel) external;\n\n  /**\n   * @notice Returns the address of the data provider.\n   * @return The address of the DataProvider\n   */\n  function getPoolDataProvider() external view returns (address);\n\n  /**\n   * @notice Updates the address of the data provider.\n   * @param newDataProvider The address of the new DataProvider\n   **/\n  function setPoolDataProvider(address newDataProvider) external;\n}\n"
    },
    "@aave/core-v3/contracts/protocol/libraries/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary DataTypes {\n  struct ReserveData {\n    //stores the reserve configuration\n    ReserveConfigurationMap configuration;\n    //the liquidity index. Expressed in ray\n    uint128 liquidityIndex;\n    //the current supply rate. Expressed in ray\n    uint128 currentLiquidityRate;\n    //variable borrow index. Expressed in ray\n    uint128 variableBorrowIndex;\n    //the current variable borrow rate. Expressed in ray\n    uint128 currentVariableBorrowRate;\n    //the current stable borrow rate. Expressed in ray\n    uint128 currentStableBorrowRate;\n    //timestamp of last update\n    uint40 lastUpdateTimestamp;\n    //the id of the reserve. Represents the position in the list of the active reserves\n    uint16 id;\n    //aToken address\n    address aTokenAddress;\n    //stableDebtToken address\n    address stableDebtTokenAddress;\n    //variableDebtToken address\n    address variableDebtTokenAddress;\n    //address of the interest rate strategy\n    address interestRateStrategyAddress;\n    //the current treasury balance, scaled\n    uint128 accruedToTreasury;\n    //the outstanding unbacked aTokens minted through the bridging feature\n    uint128 unbacked;\n    //the outstanding debt borrowed against this asset in isolation mode\n    uint128 isolationModeTotalDebt;\n  }\n\n  struct ReserveConfigurationMap {\n    //bit 0-15: LTV\n    //bit 16-31: Liq. threshold\n    //bit 32-47: Liq. bonus\n    //bit 48-55: Decimals\n    //bit 56: reserve is active\n    //bit 57: reserve is frozen\n    //bit 58: borrowing is enabled\n    //bit 59: stable rate borrowing enabled\n    //bit 60: asset is paused\n    //bit 61: borrowing in isolation mode is enabled\n    //bit 62-63: reserved\n    //bit 64-79: reserve factor\n    //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\n    //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\n    //bit 152-167 liquidation protocol fee\n    //bit 168-175 eMode category\n    //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\n    //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\n    //bit 252-255 unused\n\n    uint256 data;\n  }\n\n  struct UserConfigurationMap {\n    /**\n     * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\n     * The first bit indicates if an asset is used as collateral by the user, the second whether an\n     * asset is borrowed by the user.\n     */\n    uint256 data;\n  }\n\n  struct EModeCategory {\n    // each eMode category has a custom ltv and liquidation threshold\n    uint16 ltv;\n    uint16 liquidationThreshold;\n    uint16 liquidationBonus;\n    // each eMode category may or may not have a custom oracle to override the individual assets price oracles\n    address priceSource;\n    string label;\n  }\n\n  enum InterestRateMode {\n    NONE,\n    STABLE,\n    VARIABLE\n  }\n\n  struct ReserveCache {\n    uint256 currScaledVariableDebt;\n    uint256 nextScaledVariableDebt;\n    uint256 currPrincipalStableDebt;\n    uint256 currAvgStableBorrowRate;\n    uint256 currTotalStableDebt;\n    uint256 nextAvgStableBorrowRate;\n    uint256 nextTotalStableDebt;\n    uint256 currLiquidityIndex;\n    uint256 nextLiquidityIndex;\n    uint256 currVariableBorrowIndex;\n    uint256 nextVariableBorrowIndex;\n    uint256 currLiquidityRate;\n    uint256 currVariableBorrowRate;\n    uint256 reserveFactor;\n    ReserveConfigurationMap reserveConfiguration;\n    address aTokenAddress;\n    address stableDebtTokenAddress;\n    address variableDebtTokenAddress;\n    uint40 reserveLastUpdateTimestamp;\n    uint40 stableDebtLastUpdateTimestamp;\n  }\n\n  struct ExecuteLiquidationCallParams {\n    uint256 reservesCount;\n    uint256 debtToCover;\n    address collateralAsset;\n    address debtAsset;\n    address user;\n    bool receiveAToken;\n    address priceOracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteSupplyParams {\n    address asset;\n    uint256 amount;\n    address onBehalfOf;\n    uint16 referralCode;\n  }\n\n  struct ExecuteBorrowParams {\n    address asset;\n    address user;\n    address onBehalfOf;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint16 referralCode;\n    bool releaseUnderlying;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n  }\n\n  struct ExecuteRepayParams {\n    address asset;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    address onBehalfOf;\n    bool useATokens;\n  }\n\n  struct ExecuteWithdrawParams {\n    address asset;\n    uint256 amount;\n    address to;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ExecuteSetUserEModeParams {\n    uint256 reservesCount;\n    address oracle;\n    uint8 categoryId;\n  }\n\n  struct FinalizeTransferParams {\n    address asset;\n    address from;\n    address to;\n    uint256 amount;\n    uint256 balanceFromBefore;\n    uint256 balanceToBefore;\n    uint256 reservesCount;\n    address oracle;\n    uint8 fromEModeCategory;\n  }\n\n  struct FlashloanParams {\n    address receiverAddress;\n    address[] assets;\n    uint256[] amounts;\n    uint256[] interestRateModes;\n    address onBehalfOf;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n    uint256 maxStableRateBorrowSizePercent;\n    uint256 reservesCount;\n    address addressesProvider;\n    uint8 userEModeCategory;\n    bool isAuthorizedFlashBorrower;\n  }\n\n  struct FlashloanSimpleParams {\n    address receiverAddress;\n    address asset;\n    uint256 amount;\n    bytes params;\n    uint16 referralCode;\n    uint256 flashLoanPremiumToProtocol;\n    uint256 flashLoanPremiumTotal;\n  }\n\n  struct FlashLoanRepaymentParams {\n    uint256 amount;\n    uint256 totalPremium;\n    uint256 flashLoanPremiumToProtocol;\n    address asset;\n    address receiverAddress;\n    uint16 referralCode;\n  }\n\n  struct CalculateUserAccountDataParams {\n    UserConfigurationMap userConfig;\n    uint256 reservesCount;\n    address user;\n    address oracle;\n    uint8 userEModeCategory;\n  }\n\n  struct ValidateBorrowParams {\n    ReserveCache reserveCache;\n    UserConfigurationMap userConfig;\n    address asset;\n    address userAddress;\n    uint256 amount;\n    InterestRateMode interestRateMode;\n    uint256 maxStableLoanPercent;\n    uint256 reservesCount;\n    address oracle;\n    uint8 userEModeCategory;\n    address priceOracleSentinel;\n    bool isolationModeActive;\n    address isolationModeCollateralAddress;\n    uint256 isolationModeDebtCeiling;\n  }\n\n  struct ValidateLiquidationCallParams {\n    ReserveCache debtReserveCache;\n    uint256 totalDebt;\n    uint256 healthFactor;\n    address priceOracleSentinel;\n  }\n\n  struct CalculateInterestRatesParams {\n    uint256 unbacked;\n    uint256 liquidityAdded;\n    uint256 liquidityTaken;\n    uint256 totalStableDebt;\n    uint256 totalVariableDebt;\n    uint256 averageStableBorrowRate;\n    uint256 reserveFactor;\n    address reserve;\n    address aToken;\n  }\n\n  struct InitReserveParams {\n    address asset;\n    address aTokenAddress;\n    address stableDebtAddress;\n    address variableDebtAddress;\n    address interestRateStrategyAddress;\n    uint16 reservesCount;\n    uint16 maxNumberReserves;\n  }\n}\n"
    },
    "contracts/actions/interfaces/IMIMOProxyAction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IMIMOProxyAction {\n  function executeAction(bytes calldata data) external;\n}\n"
    },
    "contracts/actions/interfaces/IMIMOPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IMIMOPausable {\n  function pause() external;\n\n  function unpause() external;\n\n  function paused() external view returns (bool);\n}\n"
    },
    "contracts/libraries/BoringOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Simplified by BoringCrypto\n\ncontract BoringOwnableData {\n  address public owner;\n  address public pendingOwner;\n}\n\ncontract BoringOwnable is BoringOwnableData {\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  /// @notice `owner` defaults to msg.sender on construction.\n  constructor() {\n    owner = msg.sender;\n    emit OwnershipTransferred(address(0), msg.sender);\n  }\n\n  /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n  /// Can only be invoked by the current `owner`.\n  /// @param newOwner Address of the new owner.\n  /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n  /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n  function transferOwnership(\n    address newOwner,\n    bool direct,\n    bool renounce\n  ) public onlyOwner {\n    if (direct) {\n      // Checks\n      require(newOwner != address(0) || renounce, \"Ownable: zero address\");\n\n      // Effects\n      emit OwnershipTransferred(owner, newOwner);\n      owner = newOwner;\n      pendingOwner = address(0);\n    } else {\n      // Effects\n      pendingOwner = newOwner;\n    }\n  }\n\n  /// @notice Needs to be called by `pendingOwner` to claim ownership.\n  function claimOwnership() public {\n    address _pendingOwner = pendingOwner;\n\n    // Checks\n    require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\n\n    // Effects\n    emit OwnershipTransferred(owner, _pendingOwner);\n    owner = _pendingOwner;\n    pendingOwner = address(0);\n  }\n\n  /// @notice Only allows the `owner` to execute the function.\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"Ownable: caller is not the owner\");\n    _;\n  }\n}\n"
    },
    "contracts/proxy/MIMOProxyGuard.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"./interfaces/IMIMOProxyFactory.sol\";\nimport \"./interfaces/IMIMOProxyGuard.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\ncontract MIMOProxyGuard is IMIMOProxyGuard, Initializable {\n  address private _proxy;\n  IMIMOProxyFactory private _proxyFactory;\n\n  mapping(address => mapping(address => mapping(bytes4 => bool))) private _permissions;\n\n  /**\n    @notice Initializer function to set state variable upon cloning\n    @dev Called within same tx as cloning from MIMOProxyFactory\n    @param proxyFactory Address of MIMOProxyFactory\n    @param proxy Address of the MIMOProxy linked to the contract\n   */\n  function initialize(address proxyFactory, address proxy) external override initializer {\n    if (proxyFactory == address(0) || proxy == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    _proxyFactory = IMIMOProxyFactory(proxyFactory);\n    _proxy = proxy;\n  }\n\n  /**\n    @notice Gives or takes a permission from an envoy to call the given target contract and function selector\n    on behalf of the owner\n    @dev It is not an error to reset a permission on the same (envoy,target,selector) tuple multiple types.\n        Requirements:\n          - The caller must be the owner or the MIMOProxy\n    @param envoy The address of the envoy account\n    @param target The address of the target contract\n    @param selector The 4 byte function selector on the target contract\n    @param permission The boolean permission to set\n   */\n  function setPermission(\n    address envoy,\n    address target,\n    bytes4 selector,\n    bool permission\n  ) external override {\n    address owner = _proxyFactory.getProxyState(_proxy).owner;\n    if (owner != msg.sender && _proxy != msg.sender) {\n      revert Errors.UNAUTHORIZED_CALLER();\n    }\n    _permissions[envoy][target][selector] = permission;\n    emit PermissionSet(envoy, target, selector, permission);\n  }\n\n  /**\n    @param envoy The address of the envoy account\n    @param target The address of the target contract\n    @param selector The 4 byte function selector on the target contract\n    @return permission True if envoys is allowed to perform the call and false if not\n   */\n  function getPermission(\n    address envoy,\n    address target,\n    bytes4 selector\n  ) external view override returns (bool permission) {\n    permission = _permissions[envoy][target][selector];\n  }\n\n  /// @return proxy Address of the MIMOProxy associated with this contract\n  function getProxy() external view override returns (address proxy) {\n    proxy = _proxy;\n  }\n\n  /// @return proxyFactory Address of the MIMOProxyFactory\n  function getProxyFactory() external view override returns (IMIMOProxyFactory proxyFactory) {\n    proxyFactory = _proxyFactory;\n  }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !Address.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "contracts/proxy/MIMOProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimport \"./interfaces/IMIMOProxyFactory.sol\";\nimport \"./MIMOProxy.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\n/// @title MIMOProxyFactory\ncontract MIMOProxyFactory is IMIMOProxyFactory {\n  using Clones for address;\n\n  address public immutable mimoProxyGuardBase;\n\n  /// @inheritdoc IMIMOProxyFactory\n  uint256 public constant override VERSION = 1;\n\n  /// @notice proxy => proxy state\n  mapping(address => ProxyState) private _proxyStates;\n\n  /// @notice owner => proxy\n  mapping(address => IMIMOProxy) private _currentProxies;\n\n  /// @notice proxy => pending owner\n  mapping(address => address) private _pendingOwners;\n\n  modifier onlyOwner(address proxy) {\n    if (address(_currentProxies[msg.sender]) != proxy) {\n      revert Errors.NOT_OWNER(_proxyStates[proxy].owner, msg.sender);\n    }\n    _;\n  }\n\n  constructor(address _mimoProxyGuardBase) {\n    if (_mimoProxyGuardBase == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    mimoProxyGuardBase = _mimoProxyGuardBase;\n  }\n\n  /**\n    @notice Deploys a new MIMOProxy and MIMOProxyGuard\n    @dev Sets \"msg.sender\" as the owner of the MIMOProxy.\n\n   */\n  function deploy() external override {\n    address currentProxy = address(_currentProxies[msg.sender]);\n    if (address(currentProxy) != address(0)) {\n      revert Errors.ALREADY_OWNER(msg.sender, currentProxy);\n    }\n    MIMOProxy proxy = new MIMOProxy(address(this));\n    IMIMOProxyGuard proxyGuard = IMIMOProxyGuard(mimoProxyGuardBase.clone());\n\n    proxyGuard.initialize(address(this), address(proxy));\n\n    ProxyState memory proxyState = ProxyState({ owner: msg.sender, proxyGuard: proxyGuard, minGas: 5000 });\n\n    _currentProxies[msg.sender] = IMIMOProxy(proxy);\n    _proxyStates[address(proxy)] = proxyState;\n\n    emit ProxyDeployed(msg.sender, address(proxy), proxyState);\n  }\n\n  /**\n    @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    Can only be invoked by the current MIMOProxy `owner`\n    @param proxy Address ot the MIMOProxy to transfer\n    @param newOwner Address of the new owner\n   */\n  function transferOwnership(address proxy, address newOwner) external override onlyOwner(proxy) {\n    // Checks\n    if (newOwner == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    if (address(_currentProxies[newOwner]) != address(0)) {\n      revert Errors.ALREADY_OWNER(newOwner, address(_currentProxies[newOwner]));\n    }\n    // Effects\n    _pendingOwners[proxy] = newOwner;\n    emit OwnershipTransferred(proxy, msg.sender, newOwner);\n  }\n\n  /**\n    @notice Needs to be called by `pendingOwner` to claim ownership\n    @param proxy Address of the MIMOProxy to claim\n    @param clear Clear existing proxy permissions if true and maintain them if false\n   */\n  function claimOwnership(address proxy, bool clear) external override {\n    address pendingOwner = _pendingOwners[proxy];\n\n    // Checks\n    if (msg.sender != pendingOwner) {\n      revert Errors.CALLER_NOT_PENDING_OWNER(msg.sender, pendingOwner);\n    }\n\n    if (address(_currentProxies[pendingOwner]) != address(0)) {\n      revert Errors.ALREADY_OWNER(pendingOwner, address(_currentProxies[pendingOwner]));\n    }\n\n    // Effects\n    address oldOwner = _proxyStates[proxy].owner;\n    delete _currentProxies[oldOwner];\n    _currentProxies[msg.sender] = IMIMOProxy(proxy);\n    _proxyStates[proxy].owner = msg.sender;\n    delete _pendingOwners[proxy];\n    emit OwnershipClaimed(proxy, msg.sender);\n\n    if (clear) {\n      _clearPermissions(proxy);\n    }\n  }\n\n  /**\n    @notice Clear all permissions from the MIMOProxy by deploying a new MIMOProxyGuard\n    Can only be called by the MIMOProxy `owner`\n    @param proxy Addess of the MIMOProxy to clear\n   */\n  function clearPermissions(address proxy) external override onlyOwner(proxy) {\n    _clearPermissions(proxy);\n  }\n\n  /**\n    @param proxy Address of the MIMOProxy\n    @param minGas Gas to reserve for running the remainder of the \"execute\" function after the DELEGATECALL in the \n    MIMOProxy. Prevents the proxy from becoming unusable if EVM opcode gas costs change in the future.\n   */\n  function setMinGas(address proxy, uint256 minGas) external override onlyOwner(proxy) {\n    _proxyStates[proxy].minGas = minGas;\n    emit MinGasSet(proxy, minGas);\n  }\n\n  /**\n    @param proxy Address of the MIMOProxy to check\n    @return result equals true if proxy has been deployed and false if not\n   */\n  function isProxy(address proxy) external view override returns (bool result) {\n    result = _proxyStates[proxy].owner != address(0);\n  }\n\n  /**\n    @notice Returns a MIMOProxy state\n    @dev MIMOProxy state management is outsourced to this contract to prevent storage collisions\n    @param proxy Address of the MIMOProxy\n    @return proxyState as a ProxyState struct containing a MIMOProxy state variables\n   */\n  function getProxyState(address proxy) external view override returns (ProxyState memory proxyState) {\n    proxyState = _proxyStates[proxy];\n  }\n\n  /**\n    @notice Gets the current MIMOProxy of the given owner.\n    @param owner The address of the owner of the current MIMOProxy.\n   */\n  function getCurrentProxy(address owner) external view override returns (IMIMOProxy proxy) {\n    proxy = _currentProxies[owner];\n  }\n\n  /**\n    @param proxy Address of the MIMOProxy\n    @return pendingOwner that has yet to claim his ownership\n   */\n  function getPendingOwner(address proxy) external view override returns (address pendingOwner) {\n    pendingOwner = _pendingOwners[proxy];\n  }\n\n  function _clearPermissions(address proxy) internal {\n    IMIMOProxyGuard proxyGuard = IMIMOProxyGuard(mimoProxyGuardBase.clone());\n    proxyGuard.initialize(address(this), proxy);\n    _proxyStates[proxy].proxyGuard = proxyGuard;\n\n    emit PermissionsCleared(proxy, address(proxyGuard));\n  }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address implementation, bytes32 salt)\n        internal\n        view\n        returns (address predicted)\n    {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "contracts/proxy/MIMOProxy.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"../libraries/BoringBatchable.sol\";\nimport \"./interfaces/IMIMOProxy.sol\";\nimport \"./interfaces/IMIMOProxyFactory.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\n/// @title MIMOProxy\ncontract MIMOProxy is IMIMOProxy, BoringBatchable {\n  /// PUBLIC STORAGE ///\n  IMIMOProxyFactory public immutable override proxyFactory;\n\n  /// CONSTRUCTOR ///\n  constructor(address _proxyFactory) {\n    proxyFactory = IMIMOProxyFactory(_proxyFactory);\n  }\n\n  /// FALLBACK FUNCTION ///\n\n  /// @dev Called when Ether is sent and the call data is empty.\n  receive() external payable {}\n\n  /// PUBLIC NON-CONSTANT FUNCTIONS ///\n\n  /**\n    @notice Delegate calls to the target contract by forwarding the call data. Returns the data it gets back,\n    including when the contract call reverts with a reason or custom error\n    @dev Requirements:\n      - The caller must be either an owner or an envoy\n      - `target` must be a deployed contract\n      - The owner cannot be changed during the DELEGATECALL\n    @param target The address of the target contract\n    @param data Function selector plus ABI encoded data\n    @return response The response received from the target contract\n   */\n  function execute(address target, bytes calldata data) public payable override returns (bytes memory response) {\n    IMIMOProxyFactory.ProxyState memory state = proxyFactory.getProxyState(address(this));\n\n    // Check that the caller is either the owner or an envoy.\n    if (state.owner != msg.sender) {\n      bytes4 selector = bytes4(data[:4]);\n      if (!state.proxyGuard.getPermission(msg.sender, target, selector)) {\n        revert Errors.EXECUTION_NOT_AUTHORIZED(state.owner, msg.sender, target, selector);\n      }\n    }\n\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert Errors.TARGET_INVALID(target);\n    }\n\n    // Reserve some gas to ensure that the function has enough to finish the execution.\n    uint256 stipend = gasleft() - state.minGas;\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall{ gas: stipend }(data);\n\n    // Log the execution.\n    emit Execute(target, data, response);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert Errors.EXECUTION_REVERTED();\n      }\n    }\n  }\n}\n"
    },
    "contracts/libraries/BoringBatchable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\n// solhint-disable avoid-low-level-calls\n// solhint-disable no-inline-assembly\n\n// WARNING!!!\n// Combining BoringBatchable with msg.value can cause double spending issues\n// https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/\n\ncontract BoringBatchable {\n  error BatchError(bytes innerError);\n\n  /// @dev Helper function to extract a useful revert message from a failed call.\n  /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n  function _getRevertMsg(bytes memory _returnData) internal pure {\n    // If the _res length is less than 68, then\n    // the transaction failed with custom error or silently (without a revert message)\n    if (_returnData.length < 68) revert BatchError(_returnData);\n\n    assembly {\n      // Slice the sighash.\n      _returnData := add(_returnData, 0x04)\n    }\n    revert(abi.decode(_returnData, (string))); // All that remains is the revert string\n  }\n\n  /// @notice Allows batched call to self (this contract).\n  /// @param calls An array of inputs for each call.\n  /// @param revertOnFail If True then reverts after a failed call and stops doing further calls.\n  // F1: External is ok here because this is the batch function, adding it to a batch makes no sense\n  // F2: Calls in the batch may be payable, delegatecall operates in the same context, so each call in the batch has access to msg.value\n  // C3: The length of the loop is fully under user control, so can't be exploited\n  // C7: Delegatecall is only used on the same contract, so it's safe\n  function batch(bytes[] calldata calls, bool revertOnFail) external payable {\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory result) = address(this).delegatecall(calls[i]);\n      if (!success && revertOnFail) {\n        _getRevertMsg(result);\n      }\n    }\n  }\n}\n"
    },
    "contracts/attackers/SelectorBypass.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../proxy/interfaces/IMIMOProxy.sol\";\nimport \"../libraries/Errors.sol\";\n\ncontract SelectorBypass {\n  IMIMOProxy public mimoProxy;\n\n  constructor(IMIMOProxy _mimoProxy) {\n    mimoProxy = _mimoProxy;\n  }\n\n  function exploit(address target, bytes4 permissionedSelector) external {\n    bytes memory usualCallData = abi.encodeWithSelector(mimoProxy.execute.selector, target, new bytes(0));\n    (bool success, bytes memory response) = address(mimoProxy).call(\n      abi.encodePacked(usualCallData, abi.encodePacked(permissionedSelector))\n    );\n    if (!success) {\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert Errors.EXECUTION_REVERTED();\n      }\n    }\n  }\n}\n"
    },
    "contracts/attackers/ProxyPausable.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"../actions/MIMOPausable.sol\";\nimport \"../libraries/BoringBatchable.sol\";\nimport \"../proxy/interfaces/IMIMOProxy.sol\";\nimport \"../proxy/interfaces/IMIMOProxyFactory.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\n/// @title MIMOProxy\ncontract ProxyPausable is MIMOPausable, BoringBatchable {\n  function execute(address target, bytes calldata data) public payable returns (bytes memory response) {\n    // Check that the target is a valid contract.\n    if (target.code.length == 0) {\n      revert Errors.TARGET_INVALID(target);\n    }\n\n    // Delegate call to the target contract.\n    bool success;\n    (success, response) = target.delegatecall(data);\n\n    // Check if the call was successful or not.\n    if (!success) {\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert Errors.EXECUTION_REVERTED();\n      }\n    }\n  }\n}\n"
    },
    "contracts/actions/MIMOVaultActions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./MIMOPausable.sol\";\nimport \"./interfaces/IMIMOVaultActions.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport \"../core/interfaces/IVaultsCore.sol\";\nimport \"../core/interfaces/IVaultsDataProvider.sol\";\nimport \"../proxy/interfaces/IMIMOProxyFactory.sol\";\n\ncontract MIMOVaultActions is MIMOPausable, IMIMOVaultActions {\n  using SafeERC20 for IERC20;\n\n  address public immutable override contractAddress;\n\n  IVaultsCore public immutable override core;\n  IVaultsDataProvider public immutable override vaultsData;\n  IERC20 public immutable override stablex;\n  IMIMOProxyFactory public immutable override proxyFactory;\n\n  modifier whenNotPaused() override {\n    if (MIMOPausable(contractAddress).paused()) {\n      revert Errors.PAUSED();\n    }\n    _;\n  }\n\n  constructor(\n    IVaultsCore _core,\n    IVaultsDataProvider _vaultsData,\n    IERC20 _stablex,\n    IMIMOProxyFactory _proxyFactory\n  ) {\n    if (\n      address(_core) == address(0) ||\n      address(_vaultsData) == address(0) ||\n      address(_stablex) == address(0) ||\n      address(_proxyFactory) == address(0)\n    ) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    core = _core;\n    vaultsData = _vaultsData;\n    stablex = _stablex;\n    proxyFactory = _proxyFactory;\n    contractAddress = address(this);\n  }\n\n  function deposit(IERC20 collateral, uint256 amount) external override whenNotPaused {\n    collateral.safeTransferFrom(msg.sender, address(this), amount);\n    collateral.safeIncreaseAllowance(address(core), amount);\n    core.deposit(address(collateral), amount);\n  }\n\n  function depositETH() external payable override whenNotPaused {\n    core.depositETH{ value: msg.value }();\n  }\n\n  function depositAndBorrow(\n    IERC20 collateral,\n    uint256 depositAmount,\n    uint256 borrowAmount\n  ) external override whenNotPaused {\n    IVaultsCore core_ = core;\n    collateral.safeTransferFrom(msg.sender, address(this), depositAmount);\n    collateral.safeIncreaseAllowance(address(core_), depositAmount);\n    core_.depositAndBorrow(address(collateral), depositAmount, borrowAmount);\n    stablex.safeTransfer(proxyFactory.getProxyState(address(this)).owner, borrowAmount);\n  }\n\n  function depositETHAndBorrow(uint256 borrowAmount) external payable override whenNotPaused {\n    core.depositETHAndBorrow{ value: msg.value }(borrowAmount);\n    stablex.safeTransfer(proxyFactory.getProxyState(address(this)).owner, borrowAmount);\n  }\n\n  function withdraw(uint256 vaultId, uint256 amount) external override whenNotPaused {\n    core.withdraw(vaultId, amount);\n    IERC20(vaultsData.vaultCollateralType(vaultId)).safeTransfer(\n      proxyFactory.getProxyState(address(this)).owner,\n      amount\n    );\n  }\n\n  function withdrawETH(uint256 vaultId, uint256 amount) external override whenNotPaused {\n    core.withdrawETH(vaultId, amount);\n    (bool success, bytes memory response) = proxyFactory.getProxyState(address(this)).owner.call{ value: amount }(\"\");\n    if (!success) {\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert Errors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  function borrow(uint256 vaultId, uint256 amount) external override whenNotPaused {\n    core.borrow(vaultId, amount);\n    stablex.safeTransfer(proxyFactory.getProxyState(address(this)).owner, amount);\n  }\n}\n"
    },
    "contracts/actions/interfaces/IMIMOVaultActions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../../core/interfaces/IVaultsCore.sol\";\nimport \"../../core/interfaces/IVaultsDataProvider.sol\";\nimport \"../../proxy/interfaces/IMIMOProxyFactory.sol\";\n\ninterface IMIMOVaultActions {\n  function deposit(IERC20 collateral, uint256 amount) external;\n\n  function depositETH() external payable;\n\n  function depositAndBorrow(\n    IERC20 collateral,\n    uint256 depositAmount,\n    uint256 borrowAmount\n  ) external;\n\n  function depositETHAndBorrow(uint256 borrowAmount) external payable;\n\n  function withdraw(uint256 vaultId, uint256 amount) external;\n\n  function withdrawETH(uint256 vaultId, uint256 amount) external;\n\n  function borrow(uint256 vaultId, uint256 amount) external;\n\n  function core() external view returns (IVaultsCore);\n\n  function vaultsData() external view returns (IVaultsDataProvider);\n\n  function stablex() external view returns (IERC20);\n\n  function contractAddress() external view returns (address);\n\n  function proxyFactory() external view returns (IMIMOProxyFactory);\n}\n"
    },
    "contracts/actions/MIMORebalance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./MIMOFlashLoan.sol\";\nimport \"./MIMOSwap.sol\";\nimport \"./MIMOPausable.sol\";\nimport \"./interfaces/IMIMORebalance.sol\";\nimport \"../core/interfaces/IVaultsCore.sol\";\nimport \"../proxy/interfaces/IMIMOProxy.sol\";\nimport \"../proxy/interfaces/IMIMOProxyFactory.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\ncontract MIMORebalance is MIMOPausable, MIMOFlashLoan, MIMOSwap, IMIMORebalance {\n  using SafeERC20 for IERC20;\n\n  /// @notice storing address(this) as an immutable variable to be able to access it within delegatecall\n  address private immutable _contractAddress;\n  IMIMOProxyFactory public immutable override proxyFactory;\n\n  modifier whenNotPaused() override {\n    if (MIMOPausable(_contractAddress).paused()) {\n      revert Errors.PAUSED();\n    }\n    _;\n  }\n\n  constructor(\n    IAddressProvider _a,\n    IDexAddressProvider _dexAP,\n    IPool _lendingPool,\n    IMIMOProxyFactory _proxyFactory\n  ) MIMOFlashLoan(_lendingPool) MIMOSwap(_a, _dexAP) {\n    if (address(_proxyFactory) == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    proxyFactory = _proxyFactory;\n    _contractAddress = address(this);\n  }\n\n  /**\n    @notice Uses a flashloan to exchange one collateral type for another, e.g. to hold less volatile collateral\n    @notice Vault must have been created though a MIMOProxy\n    @dev Uses an AAVE V3 flashLoan that will call executeOperation\n    @param _calldata Bytes containing FlashloanData struct, RebalanceData struct, SwapData struct\n   */\n  function executeAction(bytes calldata _calldata) external override whenNotPaused {\n    (FlashLoanData memory flData, RebalanceData memory rbData, SwapData memory swapData) = abi.decode(\n      _calldata,\n      (FlashLoanData, RebalanceData, SwapData)\n    );\n    bytes memory params = abi.encode(msg.sender, rbData, swapData);\n\n    _takeFlashLoan(flData, params);\n  }\n\n  /**\n    @notice Executes an rebalance operation after taking a flashloan\n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the reblanced asset\n    @param amounts Uint array with one element corresponding to the amount of the rebalanced asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, RebalanceData struct and SwapData struct\n    @return True if success and False if failed\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override whenNotPaused returns (bool) {\n    (address owner, RebalanceData memory rbData, SwapData memory swapData) = abi.decode(\n      params,\n      (address, RebalanceData, SwapData)\n    );\n    IMIMOProxy mimoProxy = proxyFactory.getCurrentProxy(owner);\n\n    if (initiator != address(mimoProxy)) {\n      revert Errors.INITIATOR_NOT_AUTHORIZED(initiator, address(mimoProxy));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert Errors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 fromCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    fromCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amount + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      address(this),\n      abi.encodeWithSignature(\n        \"rebalanceOperation(address,uint256,uint256,uint256,(address,uint256,uint256),(uint256,bytes))\",\n        fromCollateral,\n        amount,\n        flashloanRepayAmount,\n        0,\n        rbData,\n        swapData\n      )\n    );\n\n    fromCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Used by executeOperation through MIMOProxy callback to perform rebalance logic within MIMOProxy context\n    @param fromCollateral The ERC20 token to rebalance from\n    @param swapAmount The amount of collateral to swap to for par to repay vaultdebt\n    @param flashloanRepayAmount The amount that needs to be repaid for the flashloan\n    @param fee Optional fee to be passed in the context of a ManagedRebalance to mint additional stablex to pay manager\n    @param rbData RebalanceData passed from the flashloan call\n    @param swapData SwapData passed from the flashloan call\n   */\n  function rebalanceOperation(\n    IERC20 fromCollateral,\n    uint256 swapAmount,\n    uint256 flashloanRepayAmount,\n    uint256 fee,\n    RebalanceData calldata rbData,\n    SwapData calldata swapData\n  ) external override whenNotPaused {\n    IVaultsCore core = a.core();\n    _aggregatorSwap(fromCollateral, swapAmount, swapData);\n    uint256 depositAmount = rbData.toCollateral.balanceOf(address(this));\n    rbData.toCollateral.safeIncreaseAllowance(address(core), depositAmount);\n    core.depositAndBorrow(address(rbData.toCollateral), depositAmount, rbData.mintAmount + fee);\n    core.repay(rbData.vaultId, rbData.mintAmount);\n\n    if (flashloanRepayAmount > a.vaultsData().vaultCollateralBalance(rbData.vaultId)) {\n      revert Errors.CANNOT_REPAY_FLASHLOAN();\n    }\n\n    core.withdraw(rbData.vaultId, flashloanRepayAmount);\n    fromCollateral.safeTransfer(msg.sender, flashloanRepayAmount);\n    if (fee > 0) {\n      IERC20(a.stablex()).safeTransfer(msg.sender, fee);\n    }\n  }\n}\n"
    },
    "contracts/actions/MIMOSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IMIMOSwap.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\nimport \"../core/dex/interfaces/IDexAddressProvider.sol\";\n\ncontract MIMOSwap is IMIMOSwap {\n  using SafeERC20 for IERC20;\n\n  IAddressProvider public immutable a;\n  IDexAddressProvider public immutable dexAP;\n\n  constructor(IAddressProvider _a, IDexAddressProvider _dexAP) {\n    if (address(_a) == address(0) || address(_dexAP) == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    a = _a;\n    dexAP = _dexAP;\n  }\n\n  /**\n    @notice Helper function to approve and swap an asset using an aggregator\n    @param token The starting token to swap for another asset\n    @param amount The amount of starting token to swap for\n    @param swapData SwapData containing dex index to use to swap and low-level data to call the aggregator with\n   */\n  function _aggregatorSwap(\n    IERC20 token,\n    uint256 amount,\n    SwapData calldata swapData\n  ) internal {\n    (address proxy, address router) = dexAP.getDex(swapData.dexIndex);\n\n    if (proxy == address(0) || router == address(0)) {\n      revert Errors.INVALID_AGGREGATOR();\n    }\n\n    token.safeIncreaseAllowance(proxy, amount);\n\n    (bool success, bytes memory response) = router.call(swapData.dexTxData);\n\n    if (!success) {\n      // If there is return data, the call reverted with a reason or a custom error.\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert Errors.AGGREGATOR_CALL_FAILED();\n      }\n    }\n  }\n}\n"
    },
    "contracts/attackers/ManagedRebalanceSwapReentrancy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport \"../actions/managed/interfaces/IMIMOManagedRebalance.sol\";\nimport \"../actions/MIMORebalance.sol\";\nimport \"../actions/MIMOSwap.sol\";\nimport \"../actions/interfaces/IMIMOFlashLoan.sol\";\n\n/// @notice A contract used in MIMO tests that simulates a reentrancy attempt during a managedRebalance swap\n/// @dev This contract can be set in the dexAddressProvider and called with any attacking tests\ncontract ManagedRebalanceSwapReentrancy {\n  IMIMOManagedRebalance private _targetContract;\n  IMIMOFlashLoan.FlashLoanData private _flData;\n  IMIMORebalance.RebalanceData private _rbData;\n  IMIMOSwap.SwapData private _swapData;\n\n  /// @notice All arguments needed in the fallback funciton need to be held in storage since the fallback function doesn't take any arguments\n  constructor(\n    address targetContract,\n    IMIMOFlashLoan.FlashLoanData memory flData,\n    IMIMORebalance.RebalanceData memory rbData,\n    IMIMOSwap.SwapData memory swapData\n  ) {\n    _targetContract = IMIMOManagedRebalance(targetContract);\n    _flData = flData;\n    _rbData = rbData;\n    _swapData = swapData;\n  }\n\n  /// @notice When the low level call is made from the dexAddressProvider, the fallback function will trigger and reenter\n  fallback() external payable {\n    _targetContract.rebalance(_flData, _rbData, _swapData);\n  }\n}\n"
    },
    "contracts/actions/managed/interfaces/IMIMOManagedRebalance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IMIMOManagedAction.sol\";\nimport \"../../interfaces/IMIMOFlashLoan.sol\";\nimport \"../../interfaces/IMIMORebalance.sol\";\nimport \"../../interfaces/IMIMOSwap.sol\";\n\ninterface IMIMOManagedRebalance is IMIMOManagedAction {\n  function rebalance(\n    IMIMOFlashLoan.FlashLoanData calldata flData,\n    IMIMORebalance.RebalanceData calldata rbData,\n    IMIMOSwap.SwapData calldata swapData\n  ) external;\n}\n"
    },
    "contracts/actions/managed/interfaces/IMIMOManagedAction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { IPool } from \"@aave/core-v3/contracts/interfaces/IPool.sol\";\n\nimport \"../../../core/interfaces/IAddressProvider.sol\";\nimport \"../../../core/dex/interfaces/IDexAddressProvider.sol\";\nimport \"../../../proxy/interfaces/IMIMOProxyFactory.sol\";\n\ninterface IMIMOManagedAction {\n  struct ManagedVault {\n    bool isManaged;\n    address manager;\n    uint256 allowedVariation;\n    uint256 minRatio;\n    uint256 fixedFee;\n    uint256 varFee;\n    uint256 mcrBuffer;\n  }\n\n  event ManagerSet(address manager, bool isManager);\n\n  event ManagementSet(uint256 indexed vaultId, ManagedVault managedVault);\n\n  function setManagement(uint256 vaultId, ManagedVault calldata mgtParams) external;\n\n  function setManager(address manager, bool isManager) external;\n\n  function a() external view returns (IAddressProvider);\n\n  function proxyFactory() external view returns (IMIMOProxyFactory);\n\n  function getManagedVault(uint256 vaultId) external view returns (ManagedVault memory);\n\n  function getOperationTracker(uint256 vaultId) external view returns (uint256);\n\n  function getManager(address manager) external view returns (bool);\n}\n"
    },
    "contracts/mock/MockLendingPool.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"../actions/interfaces/IMIMOFlashLoan.sol\";\n\ncontract MockLendingPool {\n  function executeOperation(\n    IMIMOFlashLoan action,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external {\n    action.executeOperation(assets, amounts, premiums, initiator, params);\n  }\n\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata interestRateModes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external {}\n}\n"
    },
    "contracts/actions/managed/MIMOManagedRebalance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./MIMOManagedAction.sol\";\nimport \"./interfaces/IMIMOManagedRebalance.sol\";\nimport \"../MIMOPausable.sol\";\nimport \"../MIMOFlashLoan.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract MIMOManagedRebalance is\n  MIMOPausable,\n  MIMOManagedAction,\n  MIMOFlashLoan,\n  ReentrancyGuard,\n  IMIMOManagedRebalance\n{\n  using SafeERC20 for IERC20;\n  using WadRayMath for uint256;\n\n  address public immutable mimoRebalance;\n\n  constructor(\n    IAddressProvider _a,\n    IPool _lendingPool,\n    IMIMOProxyFactory _proxyFactory,\n    address _mimoRebalance\n  ) MIMOManagedAction(_a, _proxyFactory) MIMOFlashLoan(_lendingPool) {\n    if (_mimoRebalance == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n\n    mimoRebalance = _mimoRebalance;\n  }\n\n  /**\n    @notice Perform a rebalance on a vault by an appointed whitelisted manager on behalf of vault owner\n    @notice Vault must have been created though a MIMOProxy\n    @dev Can only be called once a day by the manager selected by the MIMOProxy owner\n    @dev Reverts if operation results in vault value change above allowed variation or in vault ratio lower than min ratio\n    @dev NonReentrant to avoid exploits on what happens between before and after rebalance checks\n    @param flData Flashloan data struct containing flashloan parameters\n    @param rbData RebalanceData struct containing rebalance operation parameters\n    @param swapData SwapData struct containing aggegator swap parameters\n   */\n  function rebalance(\n    FlashLoanData calldata flData,\n    IMIMORebalance.RebalanceData calldata rbData,\n    IMIMOSwap.SwapData calldata swapData\n  ) external override whenNotPaused nonReentrant {\n    ManagedVault memory managedVault = _managedVaults[rbData.vaultId];\n    IVaultsDataProvider vaultsData = a.vaultsData();\n\n    _preRebalanceChecks(managedVault, rbData, vaultsData, flData.amount);\n\n    // Value of the flashloaned collateral is the same as the value of the rebalanced collateral\n    address fromCollateral = vaultsData.vaultCollateralType(rbData.vaultId);\n    uint256 rebalanceValue = a.priceFeed().convertFrom(fromCollateral, flData.amount);\n    uint256 managerFee = managedVault.fixedFee + rebalanceValue.wadMul(managedVault.varFee);\n    address vaultOwner = vaultsData.vaultOwner(rbData.vaultId);\n    uint256 vaultBId = vaultsData.vaultId(address(rbData.toCollateral), vaultOwner);\n    uint256 vaultBBalanceBefore = vaultsData.vaultCollateralBalance(vaultBId);\n\n    _takeFlashLoan(flData, abi.encode(vaultsData.vaultOwner(rbData.vaultId), managerFee, rbData, swapData));\n\n    _postRebalanceChecks(\n      managedVault,\n      rebalanceValue,\n      vaultBBalanceBefore,\n      rbData.vaultId,\n      vaultOwner,\n      address(rbData.toCollateral),\n      vaultsData\n    );\n\n    _operationTracker[rbData.vaultId] = block.timestamp;\n\n    IERC20(a.stablex()).safeTransfer(managedVault.manager, managerFee);\n  }\n\n  /**\n    @notice Routes a call from a flashloan pool to a leverage or rebalance operation\n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the reblanced asset\n    @param amounts Uint array with one element corresponding to the amount of the rebalanced asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, RebalanceData struct and SwapData struct\n    @return True if success and False if not\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override returns (bool) {\n    (\n      address mimoProxy,\n      uint256 managerFee,\n      IMIMORebalance.RebalanceData memory rbData,\n      IMIMOSwap.SwapData memory swapData\n    ) = abi.decode(params, (address, uint256, IMIMORebalance.RebalanceData, IMIMOSwap.SwapData));\n\n    if (initiator != address(this)) {\n      revert Errors.INITIATOR_NOT_AUTHORIZED(initiator, address(this));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert Errors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 fromCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    fromCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      mimoRebalance,\n      abi.encodeWithSignature(\n        \"rebalanceOperation(address,uint256,uint256,uint256,(address,uint256,uint256),(uint256,bytes))\",\n        fromCollateral,\n        amount,\n        flashloanRepayAmount,\n        managerFee,\n        rbData,\n        swapData\n      )\n    );\n\n    fromCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Helper function performing pre rebalance operation sanity checks\n    @dev Checks that :\n      - Manager is whitelisted\n      - Vault is under management\n      - Caller is the vault selected manager\n      - Rebalance amount is greater than zero\n      - Maximum daily operations has not been exceeded\n      - Mint amount is not greater than vault debt\n    @param managedVault ManagedVault struct of the vault to rebalance\n    @param rbData RebalanceData struct of the vault to rebalance\n    @param vaultsData Cached VaultsDataProvider interface for gas saving\n   */\n  function _preRebalanceChecks(\n    ManagedVault memory managedVault,\n    IMIMORebalance.RebalanceData calldata rbData,\n    IVaultsDataProvider vaultsData,\n    uint256 rebalanceAmount\n  ) internal view {\n    if (!_managers[msg.sender]) {\n      revert Errors.MANAGER_NOT_LISTED();\n    }\n    if (!managedVault.isManaged) {\n      revert Errors.VAULT_NOT_UNDER_MANAGEMENT();\n    }\n    if (msg.sender != managedVault.manager) {\n      revert Errors.CALLER_NOT_SELECTED_MANAGER();\n    }\n    if (rebalanceAmount == 0) {\n      revert Errors.REBALANCE_AMOUNT_CANNOT_BE_ZERO();\n    }\n    if (_operationTracker[rbData.vaultId] > block.timestamp - 1 days) {\n      revert Errors.MAX_OPERATIONS_REACHED();\n    }\n    if (vaultsData.vaultDebt(rbData.vaultId) < rbData.mintAmount) {\n      revert Errors.MINT_AMOUNT_GREATER_THAN_VAULT_DEBT();\n    }\n  }\n\n  /**\n    @notice Helper function performing post rebalance operation sanity checks\n    @dev Checks that :\n      - Rebalance swap slippage is below allowedVaration\n      - Vault A ratio is equal or above minRatio\n      - Vault B ratio is equal or above MCR + mcrBuffer\n    @param managedVault ManagedVault struct of the vault to rebalance\n    @param rebalanceValue Value in PAR of the amount of rebalanced collateral \n    @param vaultBBalanceBefore Collateral balance of the vault to be rebalanced to before the rebalance operation\n    @param vaultId Vault id of the vault to rebalance\n    @param vaultOwner Rebalanced vault owner\n    @param toCollateral Collateral to rebalance to\n    @param vaultsData Cached VaultsDataProvider interface for gas saving\n   */\n  function _postRebalanceChecks(\n    ManagedVault memory managedVault,\n    uint256 rebalanceValue,\n    uint256 vaultBBalanceBefore,\n    uint256 vaultId,\n    address vaultOwner,\n    address toCollateral,\n    IVaultsDataProvider vaultsData\n  ) internal view {\n    IPriceFeed priceFeed = a.priceFeed();\n    uint256 vaultBId = vaultsData.vaultId(toCollateral, vaultOwner);\n    uint256 vaultBBalanceAfter = vaultsData.vaultCollateralBalance(vaultBId);\n    uint256 swapResultValue = priceFeed.convertFrom(toCollateral, vaultBBalanceAfter - vaultBBalanceBefore);\n\n    if (!_isVaultVariationAllowed(managedVault, rebalanceValue, swapResultValue)) {\n      revert Errors.VAULT_VALUE_CHANGE_TOO_HIGH();\n    }\n\n    uint256 vaultARatioAfter = _getVaultRatio(vaultId);\n\n    if (vaultARatioAfter < managedVault.minRatio) {\n      revert Errors.FINAL_VAULT_RATIO_TOO_LOW(managedVault.minRatio, vaultARatioAfter);\n    }\n\n    uint256 vaultBRatioAfter = _getVaultRatio(vaultBId);\n    uint256 minVaultBRatio = a.config().collateralMinCollateralRatio(toCollateral) + managedVault.mcrBuffer;\n\n    if (vaultBRatioAfter < minVaultBRatio) {\n      revert Errors.FINAL_VAULT_RATIO_TOO_LOW(minVaultBRatio, vaultBRatioAfter);\n    }\n  }\n}\n"
    },
    "contracts/actions/managed/MIMOManagedAction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./interfaces/IMIMOManagedAction.sol\";\nimport { Errors } from \"../../libraries/Errors.sol\";\nimport \"../../core/interfaces/IAddressProvider.sol\";\nimport \"../../libraries/WadRayMath.sol\";\n\ncontract MIMOManagedAction is IMIMOManagedAction {\n  using WadRayMath for uint256;\n\n  IAddressProvider public immutable a;\n  IMIMOProxyFactory public immutable proxyFactory;\n\n  mapping(uint256 => ManagedVault) internal _managedVaults;\n  mapping(uint256 => uint256) internal _operationTracker;\n  mapping(address => bool) internal _managers;\n\n  constructor(IAddressProvider _a, IMIMOProxyFactory _proxyFactory) {\n    if (address(_a) == address(0) || address(_proxyFactory) == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    a = _a;\n    proxyFactory = _proxyFactory;\n  }\n\n  /**\n    @notice Sets a vault management parameters\n    @dev Can only be called by vault owner and can only appoint whitelisting managers as manger\n    @param vaultId Vault id of the vault to be put under management\n    @param mgtParams ManagedVault struct containing all management parameters\n   */\n  function setManagement(uint256 vaultId, ManagedVault calldata mgtParams) external override {\n    address vaultOwner = a.vaultsData().vaultOwner(vaultId);\n    address mimoProxy = address(proxyFactory.getCurrentProxy(msg.sender));\n\n    if (mimoProxy != vaultOwner && vaultOwner != msg.sender) {\n      revert Errors.CALLER_NOT_VAULT_OWNER(mimoProxy, vaultOwner);\n    }\n    if (!_managers[mgtParams.manager]) {\n      revert Errors.MANAGER_NOT_LISTED();\n    }\n\n    _managedVaults[vaultId] = mgtParams;\n\n    emit ManagementSet(vaultId, mgtParams);\n  }\n\n  /**\n    @notice Whitelists or removes a manager\n    @dev Can only be called by protocol manager\n    @param manager Manager address\n    @param isManager Bool value indicating if an address is allowed to manage user vaults or not\n   */\n  function setManager(address manager, bool isManager) external override {\n    IAccessController controller = a.controller();\n\n    if (!controller.hasRole(controller.MANAGER_ROLE(), msg.sender)) {\n      revert Errors.CALLER_NOT_PROTOCOL_MANAGER();\n    }\n\n    _managers[manager] = isManager;\n\n    emit ManagerSet(manager, isManager);\n  }\n\n  /**\n    @param vaultId Vault id of the queried vault\n    @return ManagedVault struct of a specific vault id\n   */\n  function getManagedVault(uint256 vaultId) external view override returns (ManagedVault memory) {\n    return _managedVaults[vaultId];\n  }\n\n  /**\n    @param vaultId Vault id of the queried vault\n    @return Timestamp of the last performed operation\n   */\n  function getOperationTracker(uint256 vaultId) external view override returns (uint256) {\n    return _operationTracker[vaultId];\n  }\n\n  /**\n    @param manager Manager address\n    @return Bool value indicating if an address is allowed to manage user vaults or not\n   */\n  function getManager(address manager) external view override returns (bool) {\n    return _managers[manager];\n  }\n\n  /**\n    @notice Helper function calculating LTV ratio\n    @param vaultId Vault id of the queried vault\n    @return Vault collateral value / vault debt\n   */\n  function _getVaultRatio(uint256 vaultId) internal view returns (uint256) {\n    IAddressProvider _a = a;\n    IVaultsDataProvider vaultsData = _a.vaultsData();\n    IPriceFeed priceFeed = _a.priceFeed();\n\n    uint256 collateralBalance = vaultsData.vaultCollateralBalance(vaultId);\n    address collateralType = vaultsData.vaultCollateralType(vaultId);\n    uint256 collateralValue = priceFeed.convertFrom(collateralType, collateralBalance);\n    uint256 vaultDebt = vaultsData.vaultDebt(vaultId);\n\n    if (vaultDebt == 0) {\n      return (type(uint256).max);\n    }\n\n    uint256 vaultRatio = collateralValue.wadDiv(vaultDebt);\n\n    return (vaultRatio);\n  }\n\n  /**\n    @notice Helper function determining if a vault value variation is within vault's management parameters\n    @param managedVault ManagedVault struct of the vault being rebalanced\n    @param rebalanceValue Value of the rebalanced collateral amount in stablex\n    @param swapResultValue Collateral value in stablex after swap\n    @return True if value change is below allowedVariation and false if it is above\n   */\n  function _isVaultVariationAllowed(\n    ManagedVault memory managedVault,\n    uint256 rebalanceValue,\n    uint256 swapResultValue\n  ) internal pure returns (bool) {\n    if (swapResultValue >= rebalanceValue) {\n      return true;\n    }\n\n    uint256 vaultVariation = (rebalanceValue - swapResultValue).wadDiv(rebalanceValue);\n\n    if (vaultVariation > managedVault.allowedVariation) {\n      return false;\n    }\n\n    return true;\n  }\n}\n"
    },
    "contracts/core/dex/DexAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./interfaces/IDexAddressProvider.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\n\ncontract DexAddressProvider is IDexAddressProvider {\n  IAddressProvider public immutable override a;\n\n  mapping(uint256 => Dex) private _dexMapping;\n\n  modifier onlyManager() {\n    IAccessController controller = a.controller();\n    require(controller.hasRole(controller.MANAGER_ROLE(), msg.sender), \"LM010\");\n    _;\n  }\n\n  constructor(IAddressProvider _a, Dex[] memory dexes) {\n    require(address(_a) != address(0), \"LM000\");\n    a = _a;\n    for (uint256 i = 0; i < dexes.length; i++) {\n      _dexMapping[i] = dexes[i];\n    }\n  }\n\n  /**\n    Set the dex address for dexMapping\n    @dev only manager or address(this) can call this method.\n    @param _index the index for the dex.\n    @param _proxy the address for the proxy.\n    @param _router the address for the router.\n  */\n  function setDexMapping(\n    uint256 _index,\n    address _proxy,\n    address _router\n  ) external override onlyManager {\n    require(_proxy != address(0), \"LM000\");\n    require(_router != address(0), \"LM000\");\n    _dexMapping[_index] = Dex({ proxy: _proxy, router: _router });\n    emit DexSet(_index, _proxy, _router);\n  }\n\n  /** \n    Returns proxy and router address for a specific dex index\n    @param index the index for the dex\n    @return (proxy address, router address)\n  */\n  function getDex(uint256 index) external view override returns (address, address) {\n    Dex memory dex = _dexMapping[index];\n    return (dex.proxy, dex.router);\n  }\n}\n"
    },
    "contracts/attackers/AutoRebalanceSwapReentrancy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\nimport \"../actions/automated/interfaces/IMIMOAutoRebalance.sol\";\nimport \"../actions/MIMOSwap.sol\";\n\n/// @notice A contract used in MIMO tests that simulates a reentrancy attempt during an autoRebalance swap\n/// @dev This contract can be set in the dexAddressProvider and called with any attacking tests\ncontract AutoRebalanceSwapReentrancy {\n  IMIMOAutoRebalance private _targetContract;\n  uint256 private _vaultId;\n  IMIMOSwap.SwapData private _swapData;\n\n  /// @notice All arguments needed in the fallback funciton need to be held in storage since the fallback function doesn't take any arguments\n  constructor(\n    address targetContract,\n    uint256 vaultId,\n    IMIMOSwap.SwapData memory swapData\n  ) {\n    _targetContract = IMIMOAutoRebalance(targetContract);\n    _vaultId = vaultId;\n    _swapData = swapData;\n  }\n\n  /// @notice When the low level call is made from the dexAddressProvider, the fallback function will trigger and reenter\n  fallback() external payable {\n    _targetContract.rebalance(_vaultId, _swapData);\n  }\n}\n"
    },
    "contracts/actions/interfaces/IMIMOLeverage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./IMIMOSwap.sol\";\nimport \"./IMIMOProxyAction.sol\";\nimport \"../../proxy/interfaces/IMIMOProxyFactory.sol\";\n\ninterface IMIMOLeverage is IMIMOSwap, IMIMOProxyAction {\n  function leverageOperation(\n    IERC20 token,\n    uint256 swapAmount,\n    uint256 flashloanRepayAmount,\n    SwapData calldata swapData\n  ) external;\n\n  function proxyFactory() external view returns (IMIMOProxyFactory);\n}\n"
    },
    "contracts/actions/MIMOLeverage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./MIMOFlashLoan.sol\";\nimport \"./MIMOSwap.sol\";\nimport \"./MIMOPausable.sol\";\nimport \"./interfaces/IMIMOLeverage.sol\";\nimport \"../core/interfaces/IVaultsCore.sol\";\nimport \"../proxy/interfaces/IMIMOProxy.sol\";\nimport \"../proxy/interfaces/IMIMOProxyFactory.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\ncontract MIMOLeverage is MIMOPausable, MIMOFlashLoan, MIMOSwap, IMIMOLeverage {\n  using SafeERC20 for IERC20;\n\n  /// @notice storing address(this) as an immutable variable to be able to access it within delegatecall\n  address private immutable _contractAddress;\n  IMIMOProxyFactory public immutable override proxyFactory;\n\n  modifier whenNotPaused() override {\n    if (MIMOPausable(_contractAddress).paused()) {\n      revert Errors.PAUSED();\n    }\n    _;\n  }\n\n  constructor(\n    IAddressProvider _a,\n    IDexAddressProvider _dexAP,\n    IPool _lendingPool,\n    IMIMOProxyFactory _proxyFactory\n  ) MIMOFlashLoan(_lendingPool) MIMOSwap(_a, _dexAP) {\n    if (address(_proxyFactory) == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    proxyFactory = _proxyFactory;\n    _contractAddress = address(this);\n  }\n\n  /**\n    @notice Leverage an asset using a flashloan to balance collateral\n    @notice Vault must have been created though a MIMOProxy\n    @dev Uses an AAVE V3 flashLoan that will call executeOperation\n    @param _calldata Bytes containing depositAmount, stablex swapAmount, struct FlashloanDat data and struc SwapData\n   */\n  function executeAction(bytes calldata _calldata) external override whenNotPaused {\n    (uint256 depositAmount, uint256 swapAmount, FlashLoanData memory flData, SwapData memory swapData) = abi.decode(\n      _calldata,\n      (uint256, uint256, FlashLoanData, SwapData)\n    );\n\n    if (depositAmount > 0) {\n      IERC20(flData.asset).safeTransferFrom(msg.sender, address(this), depositAmount);\n    }\n\n    bytes memory params = abi.encode(msg.sender, swapAmount, swapData);\n\n    _takeFlashLoan(flData, params);\n  }\n\n  /**\n    @notice Executes an leverage operation after taking a flashloan\n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the leveraged asset\n    @param amounts Uint array with one element corresponding to the amount of the leveraged asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, stablex swap amount and swap data\n    @return True if success and False if failed\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override whenNotPaused returns (bool) {\n    (address owner, uint256 swapAmount, SwapData memory swapData) = abi.decode(params, (address, uint256, SwapData));\n    IMIMOProxy mimoProxy = proxyFactory.getCurrentProxy(owner);\n\n    if (initiator != address(mimoProxy)) {\n      revert Errors.INITIATOR_NOT_AUTHORIZED(initiator, address(mimoProxy));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert Errors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 asset = IERC20(assets[0]);\n    asset.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amounts[0] + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      address(this),\n      abi.encodeWithSignature(\n        \"leverageOperation(address,uint256,uint256,(uint256,bytes))\",\n        asset,\n        swapAmount,\n        flashloanRepayAmount,\n        swapData\n      )\n    );\n\n    asset.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Used by executeOperation through MIMOProxy callback to perform leverage logic within MIMOProxy context\n    @param token ERC20 token to leverage\n    @param swapAmount Stablex swap amount\n    @param flashloanRepayAmount Amount to be repaid for the flashloan\n    @param swapData SwapData passed from the flashloan call\n   */\n  function leverageOperation(\n    IERC20 token,\n    uint256 swapAmount,\n    uint256 flashloanRepayAmount,\n    SwapData calldata swapData\n  ) external override whenNotPaused {\n    IVaultsCore core = a.core();\n    uint256 collateralBalanceBefore = token.balanceOf(address(this));\n\n    token.safeIncreaseAllowance(address(core), collateralBalanceBefore);\n    core.depositAndBorrow(address(token), collateralBalanceBefore, swapAmount);\n\n    IERC20 stablex = IERC20(a.stablex());\n\n    _aggregatorSwap(stablex, swapAmount, swapData);\n\n    uint256 collateralBalanceAfter = token.balanceOf(address(this));\n\n    if (flashloanRepayAmount > collateralBalanceAfter) {\n      revert Errors.CANNOT_REPAY_FLASHLOAN();\n    }\n\n    if (collateralBalanceAfter > flashloanRepayAmount) {\n      token.safeIncreaseAllowance(address(core), collateralBalanceAfter - flashloanRepayAmount);\n      core.deposit(address(token), collateralBalanceAfter - flashloanRepayAmount);\n    }\n\n    token.safeTransfer(msg.sender, flashloanRepayAmount);\n  }\n}\n"
    },
    "contracts/actions/MIMOEmptyVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"../core/interfaces/IVaultsCore.sol\";\nimport \"../proxy/interfaces/IMIMOProxy.sol\";\nimport \"../proxy/interfaces/IMIMOProxyFactory.sol\";\nimport \"./interfaces/IMIMOEmptyVault.sol\";\nimport \"./MIMOFlashLoan.sol\";\nimport \"./MIMOSwap.sol\";\nimport \"./MIMOPausable.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\ncontract MIMOEmptyVault is MIMOPausable, MIMOSwap, MIMOFlashLoan, IMIMOEmtpyVault {\n  using SafeERC20 for IERC20;\n\n  /// @notice storing address(this) as an immutable variable to be able to access it within delegatecall\n  address private immutable _contractAddress;\n  IMIMOProxyFactory public immutable override proxyFactory;\n\n  modifier whenNotPaused() override {\n    if (MIMOPausable(_contractAddress).paused()) {\n      revert Errors.PAUSED();\n    }\n    _;\n  }\n\n  constructor(\n    IAddressProvider _a,\n    IDexAddressProvider _dexAP,\n    IPool _lendingPool,\n    IMIMOProxyFactory _proxyFactory\n  ) MIMOFlashLoan(_lendingPool) MIMOSwap(_a, _dexAP) {\n    if (address(_proxyFactory) == address(0)) {\n      revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\n    }\n    proxyFactory = _proxyFactory;\n    _contractAddress = address(this);\n  }\n\n  /**\n    @notice Uses a flashloan to repay all debts for a vault and send all collateral in the vault to the owner\n    @notice Vault must have been created though a MIMOProxy\n    @dev Uses an AAVE V3 flashLoan that will call executeOperation\n    @param _calldata Bytes containing vaultId, FlashloanData struct, RebalanceData struct, SwapData struct\n   */\n  function executeAction(bytes calldata _calldata) external override whenNotPaused {\n    (uint256 vaultId, FlashLoanData memory flData, SwapData memory swapData) = abi.decode(\n      _calldata,\n      (uint256, FlashLoanData, SwapData)\n    );\n    bytes memory params = abi.encode(msg.sender, vaultId, swapData);\n\n    _takeFlashLoan(flData, params);\n  }\n\n  /**\n    @notice Executes an emptyVault operation after taking a flashloan\n    @dev Integrates with AAVE V3 flashLoans\n    @param assets Address array with one element corresponding to the address of the target vault asset\n    @param amounts Uint array with one element corresponding to the amount of the target vault asset\n    @param premiums Uint array with one element corresponding to the flashLoan fees\n    @param initiator Initiator of the flashloan; can only be MIMOProxy owner\n    @param params Bytes sent by this contract containing MIMOProxy owner, target vault id, SwapData struct\n    @return True if success and False if failed\n   */\n  function executeOperation(\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata premiums,\n    address initiator,\n    bytes calldata params\n  ) external override whenNotPaused returns (bool) {\n    (address owner, uint256 vaultId, SwapData memory swapData) = abi.decode(params, (address, uint256, SwapData));\n    IMIMOProxy mimoProxy = proxyFactory.getCurrentProxy(owner);\n\n    if (initiator != address(mimoProxy)) {\n      revert Errors.INITIATOR_NOT_AUTHORIZED(initiator, address(mimoProxy));\n    }\n    if (msg.sender != address(lendingPool)) {\n      revert Errors.CALLER_NOT_LENDING_POOL(msg.sender, address(lendingPool));\n    }\n\n    IERC20 vaultCollateral = IERC20(assets[0]);\n    uint256 amount = amounts[0];\n    vaultCollateral.safeTransfer(address(mimoProxy), amounts[0]);\n    uint256 flashloanRepayAmount = amount + premiums[0];\n\n    IMIMOProxy(mimoProxy).execute(\n      address(this),\n      abi.encodeWithSignature(\n        \"emptyVaultOperation(address,address,uint256,uint256,uint256,(uint256,bytes))\",\n        owner,\n        vaultCollateral,\n        vaultId,\n        amount,\n        flashloanRepayAmount,\n        swapData\n      )\n    );\n\n    vaultCollateral.safeIncreaseAllowance(address(lendingPool), flashloanRepayAmount);\n\n    return true;\n  }\n\n  /**\n    @notice Used by executeOperation through MIMOProxy callback to perform rebalance logic within MIMOProxy context\n    @notice There will likely be some leftover par after repaying the loan; that will also be sent back to the user\n    @param owner Address of the mimoProxy owner \n    @param vaultCollateral Collateral of the vault to empty\n    @param vaultId vault id of the vault to be emptied\n    @param swapAmount Amount of collateral to swap to for par to repay vaultdebt\n    @param flashLoanRepayAmount Amount of collateral to repay to flashloan protocol at the end of the tx \n    @param swapData SwapData passed from the flashloan call\n   */\n  function emptyVaultOperation(\n    address owner,\n    IERC20 vaultCollateral,\n    uint256 vaultId,\n    uint256 swapAmount,\n    uint256 flashLoanRepayAmount,\n    SwapData calldata swapData\n  ) external whenNotPaused {\n    IERC20 stablex = IERC20(a.stablex());\n    IVaultsCore core = a.core();\n\n    uint256 beforeParBalance = stablex.balanceOf(address(this));\n    _aggregatorSwap(vaultCollateral, swapAmount, swapData);\n\n    stablex.safeIncreaseAllowance(address(core), stablex.balanceOf(address(this)));\n    core.repayAll(vaultId);\n\n    uint256 withdrawAmount = a.vaultsData().vaultCollateralBalance(vaultId);\n\n    core.withdraw(vaultId, withdrawAmount);\n\n    if (flashLoanRepayAmount > vaultCollateral.balanceOf(address(this))) {\n      revert Errors.CANNOT_REPAY_FLASHLOAN();\n    }\n\n    // Send flashloanRepayAmount to this contract for loan repayment\n    vaultCollateral.safeTransfer(msg.sender, flashLoanRepayAmount);\n\n    // Transfer leftover PAR and collateral from emptying vault to owner\n    if (withdrawAmount > flashLoanRepayAmount) {\n      // Send any extra asset amount to owner\n      vaultCollateral.safeTransfer(owner, withdrawAmount - flashLoanRepayAmount);\n    } // else if flashLoanRepayAmount is greater than amount, the transaction might need to use funds from MIMOProxy\n\n    uint256 afterParBalance = stablex.balanceOf(address(this));\n    if (afterParBalance > beforeParBalance) {\n      stablex.safeTransfer(owner, afterParBalance - beforeParBalance); // Send remaining par from swap to owner\n    }\n  }\n}\n"
    },
    "contracts/actions/interfaces/IMIMOEmptyVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./IMIMOSwap.sol\";\nimport \"./IMIMOProxyAction.sol\";\nimport \"../../proxy/interfaces/IMIMOProxyFactory.sol\";\n\ninterface IMIMOEmtpyVault is IMIMOProxyAction, IMIMOSwap {\n  function emptyVaultOperation(\n    address owner,\n    IERC20 vaultCollateral,\n    uint256 vaultId,\n    uint256 swapAmount,\n    uint256 flashloanRepayAmount,\n    SwapData calldata swapData\n  ) external;\n\n  function proxyFactory() external view returns (IMIMOProxyFactory);\n}\n"
    },
    "contracts/core/liquidityMining/interfaces/IDemandMiner.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDemandMiner {\n  function deposit(uint256 amount) external;\n\n  function withdraw(uint256 amount) external;\n\n  function token() external view returns (IERC20);\n}\n"
    },
    "contracts/core/liquidityMining/interfaces/IMIMODistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"../../governance/interfaces/IGovernanceAddressProvider.sol\";\nimport \"./IBaseDistributor.sol\";\n\ninterface IMIMODistributorExtension {\n  function startTime() external view returns (uint256);\n\n  function currentIssuance() external view returns (uint256);\n\n  function weeklyIssuanceAt(uint256 timestamp) external view returns (uint256);\n\n  function totalSupplyAt(uint256 timestamp) external view returns (uint256);\n}\n\ninterface IMIMODistributor is IBaseDistributor, IMIMODistributorExtension {}\n"
    },
    "contracts/core/liquidityMining/interfaces/IBaseDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\n\nimport \"../../governance/interfaces/IGovernanceAddressProvider.sol\";\n\ninterface IBaseDistributor {\n  event PayeeAdded(address account, uint256 shares);\n  event TokensReleased(uint256 newTokens, uint256 releasedAt);\n\n  /**\n    Public function to release the accumulated new MIMO tokens to the payees.\n    @dev anyone can call this.\n  */\n  function release() external;\n\n  /**\n    Updates the payee configuration to a new one.\n    @dev will release existing fees before the update.\n    @param _payees Array of payees\n    @param _shares Array of shares for each payee\n  */\n  function changePayees(address[] memory _payees, uint256[] memory _shares) external;\n\n  function totalShares() external view returns (uint256);\n\n  function shares(address) external view returns (uint256);\n\n  function a() external view returns (IGovernanceAddressProvider);\n\n  function mintableTokens() external view returns (uint256);\n\n  /**\n    Get current configured payees.\n    @return array of current payees.\n  */\n  function getPayees() external view returns (address[] memory);\n}\n"
    },
    "contracts/core/v1/interfaces/IVaultsDataProviderV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma experimental ABIEncoderV2;\npragma solidity ^0.8.0;\nimport \"./IAddressProviderV1.sol\";\n\ninterface IVaultsDataProviderV1 {\n  struct Vault {\n    // borrowedType support USDX / PAR\n    address collateralType;\n    address owner;\n    uint256 collateralBalance;\n    uint256 baseDebt;\n    uint256 createdAt;\n  }\n\n  //Write\n  function createVault(address _collateralType, address _owner) external returns (uint256);\n\n  function setCollateralBalance(uint256 _id, uint256 _balance) external;\n\n  function setBaseDebt(uint256 _id, uint256 _newBaseDebt) external;\n\n  function a() external view returns (IAddressProviderV1);\n\n  // Read\n  function baseDebt(address _collateralType) external view returns (uint256);\n\n  function vaultCount() external view returns (uint256);\n\n  function vaults(uint256 _id) external view returns (Vault memory);\n\n  function vaultOwner(uint256 _id) external view returns (address);\n\n  function vaultCollateralType(uint256 _id) external view returns (address);\n\n  function vaultCollateralBalance(uint256 _id) external view returns (uint256);\n\n  function vaultBaseDebt(uint256 _id) external view returns (uint256);\n\n  function vaultId(address _collateralType, address _owner) external view returns (uint256);\n\n  function vaultExists(uint256 _id) external view returns (bool);\n\n  function vaultDebt(uint256 _vaultId) external view returns (uint256);\n\n  function debt() external view returns (uint256);\n\n  function collateralDebt(address _collateralType) external view returns (uint256);\n}\n"
    },
    "contracts/core/v1/interfaces/IFeeDistributorV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IAddressProviderV1.sol\";\n\ninterface IFeeDistributorV1 {\n  event PayeeAdded(address indexed account, uint256 shares);\n  event FeeReleased(uint256 income, uint256 releasedAt);\n\n  function release() external;\n\n  function changePayees(address[] memory _payees, uint256[] memory _shares) external;\n\n  function a() external view returns (IAddressProviderV1);\n\n  function lastReleasedAt() external view returns (uint256);\n\n  function getPayees() external view returns (address[] memory);\n\n  function totalShares() external view returns (uint256);\n\n  function shares(address payee) external view returns (uint256);\n}\n"
    },
    "contracts/actions/MIMOProxyActions.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity 0.8.10;\n\nimport \"../proxy/interfaces/IMIMOProxy.sol\";\nimport { Errors } from \"../libraries/Errors.sol\";\n\ncontract MIMOProxyActions {\n  /**\n    @notice Sends ETH back to owner of the MIMOProxy\n    Can only be called by MIMOProxy owner\n   */\n  function withdrawETH() external payable {\n    (bool success, bytes memory response) = IMIMOProxy(address(this))\n      .proxyFactory()\n      .getProxyState(address(this))\n      .owner\n      .call{ value: address(this).balance }(\"\");\n    if (!success) {\n      if (response.length > 0) {\n        assembly {\n          let returndata_size := mload(response)\n          revert(add(32, response), returndata_size)\n        }\n      } else {\n        revert Errors.EXECUTION_REVERTED();\n      }\n    }\n  }\n\n  /**\n    @notice Call multiple functions from current contract and return the data from all of them if they all succeed\n    @param targets Address array of all contracts to call\n    @param data Bytes array of encoded function data for each target call\n   */\n  function multicall(address[] calldata targets, bytes[] calldata data) external returns (bytes[] memory) {\n    if (targets.length != data.length) {\n      revert Errors.TARGETS_LENGTH_DIFFERENT_THAN_DATA_LENGTH(targets.length, data.length);\n    }\n    bytes[] memory results = new bytes[](data.length);\n    for (uint256 i = 0; i < targets.length; i++) {\n      // Check that the target is a valid contract.\n      if (targets[i].code.length == 0) {\n        revert Errors.TARGET_INVALID(targets[i]);\n      }\n      (bool success, bytes memory response) = targets[i].call(data[i]);\n      if (!success) {\n        if (response.length > 0) {\n          assembly {\n            let returndata_size := mload(response)\n            revert(add(32, response), returndata_size)\n          }\n        } else {\n          revert Errors.EXECUTION_REVERTED();\n        }\n      }\n      results[i] = response;\n    }\n    return results;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}